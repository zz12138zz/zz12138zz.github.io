<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Yizumi Konata"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://example.com/2020/12/21/c++/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="华中科技大学计算机学院19级C++程序设计课程笔记，内容大部分来源于和ppt。作者菜的一批，若有任何纰漏或错误可以发邮件至954988021@qq.com指出有误的地方并喷我一顿，十分感谢（不过估计也没人看）。实验材料、源码、实验报告地址附在博客最后。"><meta property="og:type" content="article"><meta property="og:title" content="C++面向对象编程"><meta property="og:url" content="http://example.com/2020/12/21/C++/index.html"><meta property="og:site_name" content="纯路人的博客"><meta property="og:description" content="华中科技大学计算机学院19级C++程序设计课程笔记，内容大部分来源于和ppt。作者菜的一批，若有任何纰漏或错误可以发邮件至954988021@qq.com指出有误的地方并喷我一顿，十分感谢（不过估计也没人看）。实验材料、源码、实验报告地址附在博客最后。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231831993.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201109154535187.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129103416061.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129103924426.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129152651973.png"><meta property="article:published_time" content="2020-12-21T06:36:02.000Z"><meta property="article:modified_time" content="2024-06-06T15:04:55.392Z"><meta property="article:author" content="Yizumi Konata"><meta property="article:tag" content="C++"><meta property="article:tag" content="编程语言学习"><meta property="article:tag" content="课程笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231831993.png"><link rel="icon" type="image/png" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"><meta name="theme-color" content="#1890ff"><link rel="shortcut icon" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"><title>C++面向对象编程 - 纯路人的博客</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><script src="/js/libs/anime.min.js"></script><h1 class="ml13">纯路人的博客</h1><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }</script></div><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/fonts.css"><link rel="stylesheet" href="/fonts/Satoshi/satoshi.css"><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet"><script id="hexo-configurations">window.config={hostname:"example.com",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"5rem",h2:"4rem",h3:"2.8rem",h4:"2.5rem",h5:"2.2rem",h6:"2rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#1890ff",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/monika.webp",dark:"/images/monika.webp"},title:"为了幸福地生活，我就必须与世界保持一致",subtitle:{text:["Down the rabbit hole..."],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:80,backing_speed:100,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#000",dark:"#fff"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!0,family:"Noto Sans SC",url:"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},social_links:{enable:!0,style:"default",links:{github:"https://github.com/zz12138zz",instagram:null,zhihu:null,twitter:null,email:"954988021@qq.com"},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!0,type:"fixed",audios:[{name:"テルーの呗",artist:"手嶌葵",url:"https://zz12138music.oss-cn-beijing.aliyuncs.com/1.mp3",cover:"https://zz12138music.oss-cn-beijing.aliyuncs.com/1.png",lrc:null},{name:"勘ぐれい",artist:"ずっと真夜中でいいのに",url:"https://zz12138music.oss-cn-beijing.aliyuncs.com/2.m4a",cover:"https://zz12138music.oss-cn-beijing.aliyuncs.com/2.jpg"}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.6.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},Categories:{icon:"fa-regular fa-folder",path:"/categories/"},Tags:{icon:"fa-regular fa-tags",path:"/tags/"},About:{icon:"fa-regular fa-user",path:"/about/"}},search:{enable:!0,preload:!0},tags:{Tags:{icon:"fa-solid fa-tags",path:"/tags/"}},categories:{Categories:{icon:"fa-solid fa-folder",path:"/categories/"}}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.2.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"> </a><a class="logo-title" href="/">纯路人的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> ARCHIVES</a></li><li class="navbar-item"><a href="/categories/"><i class="fa-regular fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/tags/"><i class="fa-regular fa-tags fa-fw"></i> TAGS</a></li><li class="navbar-item"><a href="/about/"><i class="fa-regular fa-user fa-fw"></i> ABOUT</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>ARCHIVES </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/"><span>CATEGORIES </span><i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags/"><span>TAGS </span><i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about/"><span>ABOUT </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">C++面向对象编程</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://zz12138img.oss-cn-beijing.aliyuncs.com/konata.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Yizumi Konata</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2020-12-21 14:36:02</span> <span class="mobile">2020-12-21 14:36:02</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-06-06 23:04:55</span> <span class="mobile">2024-06-06 23:04:55</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/C/">C++</a>&nbsp;</li><li>| <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">编程语言学习</a>&nbsp;</li><li>| <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="第一章-c引论">第一章 C++引论</h2><h3 id="程序设计语言">程序设计语言</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231831993.png" alt="image-20240605231831993"></p><p>面向过程程序设计程序基本单元是函数，面向对象程序设计程序基本单元是类。</p><h3 id="程序编译技术">程序编译技术</h3><p>编译过程包括：</p><ul><li>预处理：替换预处理指令<code>#define #include</code>等</li><li>词法分析：产生单词序列（token）</li><li>语法分析：简单分析语法，如分号，括号的配对，<code>if else</code>配对等</li><li>代码生成：生成低级语言代码如机器语言或汇编语言。<em>标识符在生成低级代码会进行换名，C和C++换名策略不同</em></li><li>模块连接：将中间代码和标准库、非标准库连接起来，形成一个可执行的程序。<em>静态连接lib库与动态连接dll库</em></li></ul><h3 id="面向对象的程序设计语言">面向对象的程序设计语言</h3><ul><li>纯OO型语言：程序全部由类构成：SMALLTALK、JAVA、 C#、OBJECT-ORIENTED PASCAL</li><li>混合型OO语言：程序由类、全局过程或函数以及全局变量定义构成：C++</li></ul><h4 id="面向对象的基本概念">面向对象的基本概念</h4><ul><li>函数绑定：找到函数入口地址的过程。其中<strong>早期绑定</strong>发生在<strong>程序开始执行前</strong>，由编译程序或者操作系统静态或动态连接完成；<strong>晚期绑定</strong>发生在<strong>程序运行过程中</strong>，由程序自己完成</li><li>对象：抽象出来的数据对象，描述一个问题中的一件事物</li><li>类：描述对象共同特征和行为的数据类型。</li><li>封装：将对象的数据结构和算法包装在一起，描述对象的组织结构和功能，提供外部访问接口但是屏蔽对象的行为细节</li><li>交互：直接交互指一对象调用另一对象的“操作”、“功能”或“函数”; 间接交互通过发送或监听消息完成。</li><li>重载：用一个函数名称来定义完成不同功能的多个函数。重载函数要么参数个数不同，要么参数类型不同，或者都不同</li><li>多态：通过一个函数名能表现出不同行为。重载函数行为发生在早期绑定，属于静态多态；虚函数行为发生在晚期绑定，属于动态多态。多态一般指动态多态。多态增强了程序的泛用性。</li><li>继承：一个对象获得另一个或多个对象的“特征”和“行为”， 从而实现了软件重用。</li><li>抽象：从事物到概念，从低级概念到高级概念</li><li>抽象类：抽象级别最高的类，无法描述具体特征和行为。</li></ul><h3 id="c语言的特点">C++语言的特点</h3><ul><li>兼容C，代码质量高，速度快</li><li>多继承，强类型，混合型面向对象</li><li>支持面向对象的运算符重载</li><li>提供函数模板和类模板等高级抽象机制</li><li>支持面向对象的异常处理</li><li>支持名字空间</li></ul><p>C++由三种头文件，一种是老式的C头文件，与C的头文件一致；一种是C++新的头文件，没有<code>.h</code>后缀；一种是老式C头文件的封装，将老式头文件的<code>.h</code>后缀删去，在前面加上c，与老式头文件的区别在于有名字空间。</p><h2 id="第二章-类型常量和变量">第二章 类型、常量和变量</h2><h3 id="c的单词">C++的单词</h3><p>单词包括标识符和保留字。保留字不可用做自定义标识符。保留字表如下</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201109154535187.png" alt="保留字表"></p><h3 id="基础类型变量及其类型解析">基础类型变量及其类型解析</h3><h4 id="内置数据类型">内置数据类型</h4><p>数据类型告诉我们数据在内存中的表示方式。C++的内置数据类型如下表</p><table><thead><tr class="header"><th><strong>类型</strong></th><th><strong>含义</strong></th><th><strong>最小尺寸</strong></th></tr></thead><tbody><tr class="odd"><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr class="even"><td>char</td><td>字符</td><td>8位</td></tr><tr class="odd"><td>wchat_t</td><td>宽字符</td><td>16位</td></tr><tr class="even"><td>char16_t</td><td>Unicode字符</td><td>16位</td></tr><tr class="odd"><td>char32_t</td><td>Unicode字符</td><td>32位</td></tr><tr class="even"><td>short</td><td>短整型</td><td>16位</td></tr><tr class="odd"><td>int</td><td>整型</td><td>16位</td></tr><tr class="even"><td>long</td><td>长整型</td><td>32位</td></tr><tr class="odd"><td>long long</td><td>长整型</td><td>64位</td></tr><tr class="even"><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr class="odd"><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr class="even"><td>long double</td><td>扩展精度浮点数</td><td>10位有效数字</td></tr></tbody></table><p><strong>注：每种数据类型的字节数与硬件、操作系统、编译有关。默认一般整数常量当作为int类型，浮点常量当作double类型。</strong></p><p>预定义类型的格式化输入输出格式与C一致，不做赘述</p><p>C++在使用变量前要先对变量进行定义或声明</p><ul><li>变量声明：描述变量的类型及名称，没有初始化，声明是针对已经定义过的变量进行的，可以声明多次</li><li>变量定义：描述变量的类型及名称，为变量分配内存空间并初始化，只能定义一次</li></ul><p>声明变量时需要用到关键字<code>extern</code>，且不能初始化（若初始化则定义一个变量）</p><p>C++提供了多种初始化变量的方法，如下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//C风格</span></span><br><span class="line"><span class="type">int</span> b={<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> d{<span class="number">0</span>}; <span class="comment">//列表初始化，在存在精度损失时会报告编译错误，相对安全</span></span><br></pre></td></tr></table></figure></div><p>如果定义变量时没有指定初始值，则变量呗赋予默认值，有一下几种情况</p><ul><li>内置类型全局变量和局部静态变量初始化为0</li><li>函数内部的内置类型局部变量的值未确定，直接访问会报错</li><li>类对象取决于构造函数的定义</li></ul><h4 id="关键字staticconstconstexprvolatileinline">关键字static，const，constexpr，volatile，inline</h4><ul><li>static用以定义静态变量，分为模块静态变量和局部静态变量。模块静态变量在函数外部定义，作用域为当前文件，在函数内部可以用<code>::</code>访问。局部静态变量在函数中定义，作用域为该函数，但生命周期为整个程序。</li><li>const或constexpr说明或定义的变量，定义时必须同时初始化。当前程序只能读不能修改其值。其中constexpr变量必须用编译时可计算表达式（ 常量表达式）初始化。</li><li>volatile说明或定义的变量，可以后初始化。其值不一定非要由当前程序修改，可由其他程序修改。</li><li>保留字inline用于定义函数外部变量或函数外部静态变量、类内部的静态数据成员。inline函数外部变量的作用域和inline函数外部静态变量一样,都是局限于当前代码文件的，相当于默认加了static。</li></ul><h3 id="指针类型变量">指针类型变量</h3><p>主体知识与C中一样。需要强化理解的是如何识别复合类型指针。</p><p>指针类型的变量使用说明和定义的，即 <code>*</code>后面的才是描述指针的内存类型的，而<code>*</code>前面的部分描述的是指针所指向的数据的基本类型以及内存类型的。</p><h4 id="指针使用注意事项">指针使用注意事项</h4><ul><li>只读单元的指针(地址)不能赋给指向可写单元的指针变量，而可写单元的指针(地址)能赋给指向只读单元的指针变量。</li><li>父类指针可以指向子类对象</li><li>指针初始化三种方法：</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1=<span class="literal">nullptr</span>;<span class="comment">//推荐</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3=<span class="literal">NULL</span><span class="comment">//需要先#include&lt;cstdlib&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="引用类型变量">引用类型变量</h3><p>引用为变量起了一个别名，引用类型变量的声明符用<code>&amp;</code>来修饰变量名（指左值引用）。引用类型变量必须马上初始化。</p><p>在C++中，左值指的是可以寻址的值，右值指的是不能寻址的值。左值持久、右值短暂。左值具有持久的状态（取决于对象的生命周期），而右值要么是字面量，要么是在表达式求值过程中创建的临时对象。注意，<code>const</code>类型的左值引用可以引用右值，如直接<code>const int &amp;w=4;</code>此时相当于为4分配了一块内存空间。</p><p>引用的本质是常量指针。但是引用不分配物理内存，因此无法定义引用的有一定以及引用类型的数组，且不能被重新赋值。同时由于计算机没有按位编址，因此不能引用位段成员。</p><p><strong>引用初始化时，除了二种例外情况，引用类型都要与绑定的对象严格匹配，除了const类型引用和父类引用绑定子类</strong>（与指针类似）</p><p>右值引用用<code>&amp;&amp;</code>修饰变量名，必须引用右值。右值引用可以进行赋值，如<code>int &amp;&amp;a = 1;a = 2;</code> 是合法的但是右值引用使用的是右值对象的缓存，自己并不分配内存，这一点的性质与左值引用一致。但是右值引用可以引用位段成员，因为位段成员无址。</p><h3 id="数组结构联合">数组，结构，联合</h3><p>没啥好说的。。。。</p><h2 id="第三章-语句函数及程序设计">第三章 语句，函数及程序设计</h2><h3 id="c的语句">C++的语句</h3><p>与C一致，需要了解的是asm语句和static assert静态断言。asm语句可以在C或C++程序中插入汇编代码。static assert使用格式为<code>static assert(条件表达式，" 输出信息")</code>，不满足条件则编译报错并抛出报错信息。</p><h3 id="c的函数">C++的函数</h3><p>基本知识与C一致。</p><p>函数可说明或定义为四种作用域：</p><ul><li>全局函数(默认)</li><li>内联即inline函数：可在程序文件内或类内说明或定义，只能被当前程序文件的程序调用。它是局部文件作用域的，可被编译优化掉</li><li>外部即extern函数：声明外部函数用</li><li>静态即static函数：可在程序文件内或类内说明或定义。类内的静态函数不是局部文件作用域的，程序文件内的静态函数是局部文件作用域的。</li></ul><p>函数可以定义省略参数，用<code>...</code> 表示可以接受0至任意个任意类型的参数。通常须提供一个参数表示省略了多少个实参。由于省略参数连续存放，故可以通过指针移动访问。如下</p><p></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n, ...)</span> <span class="comment">//n为省略参数的个数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">long</span> s = <span class="number">0</span>; <span class="type">int</span>* p = &amp;n + <span class="number">1</span>;    <span class="comment">//p指向第1个省略参数</span></span><br><span class="line">    <span class="comment">//若省略参数为其他类型，需要声明为相应类型的指针并对n的地址进行强制类型转换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)  s += p[k];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> s = <span class="built_in">sum</span>(<span class="number">3</span>, a, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//执行完后s=9</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p></p><p>函数可以定义默认参数，调用时若未传实参则用默认值。默认值所用的表达式不能出现同参数表的参数，否则可能会因为传递参数的顺序的问题造成错误。所有默认值必须出现在参数表的右边。</p><p>内联inline函数调用会被编译进行优化，即直接将其函数体插入到调用处，而不是编译为call指令，这样可以减少调用开销，提高程序执行效率。若函数为虚函数、或包含分支或取过函数地址，或调用时未见函数体（函数体定义在调用处后面），则内联失败。失败不代表程序有错，只是被编译为函数调用指令。</p><p>重载函数：通过<strong>参数差异</strong>识别重载函数，即若<strong>参数的个数或者类型有所不同（至少一个参数类型不一致）</strong>，则同名的函数被自动视为重载函数。<strong>重载只与参数类型有关，与返回类型无关</strong>，若参数个数和类型完全相同、仅仅返回类型不同是不允许的。<strong>当使用缺省参数和省略号时，函数重载容易引起歧义，会使编译器报错</strong></p><h3 id="作用域">作用域</h3><ul><li>程序可由若干代码文件(.cpp)构成，整个程序为<strong>全局作用域</strong>：<strong>全局变量</strong>和函数**属于此作用域。</li><li>稍小的作用域是代码<strong>当前文件作用域</strong>：函数外的<strong>static变量和函数</strong>属此作用域。</li><li>更小的作用域是<strong>函数体</strong>：<strong>函数局部变量和函数参数</strong>属于此作用域。</li><li>在函数体内又有更小的<strong>复合语句块作用域</strong>。</li><li>最小的作用域是<strong>数值表达式</strong>：常量在此作用域。</li></ul><p>除全局作用域外，同层不同作用域可以定义同名的常量、变量、函数。但他们为不同的实体。如果变量和常量是对象，则进入面向对象的作用域。同名变量、函数的作用域越小、被访问的优先级越高。</p><h3 id="生命周期">生命周期</h3><ul><li>常量的生命期即其所在表达式。</li><li>函数参数或自动变量的生命期当退出其作用域时结束。</li><li>静态变量的生命期从其被运行到的位置开始，直到整个程序结束。</li><li>全局变量的生命期从其初始化位置开始，直到整个程序结束。</li><li>通过new产生的对象如果不delete，则永远生存（内存泄漏）。</li><li>外层作用域变量不要引用内层作用域自动变量（包括函数参数），否则导致变量的值不确定：因为内存变量的生命已经结束（内存已做他用）</li></ul><h2 id="第四章-c的类">第四章 C++的类</h2><h3 id="类的声明和定义">类的声明和定义</h3><p><code>class</code>、<code>struct</code>或<code>union</code>可用来声明和定义类。类的声明直接使用<code>class 类型名;</code>即可，而类的定义则需要给出其成员的声明或定义，类的实现则需要即定义类的函数成员的函数体。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">double</span> radius;<span class="comment">//数据成员</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Circle</span>();<span class="comment">//构造函数声明</span></span><br><span class="line">    	<span class="built_in">Circle</span>(<span class="type">double</span> r);<span class="comment">//构造函数声明</span></span><br><span class="line">    	<span class="function"><span class="type">double</span> <span class="title">findarea</span><span class="params">()</span></span>;<span class="comment">//成员函数声明</span></span><br><span class="line">};<span class="comment">//类的定义，注意分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实现</span></span><br><span class="line">Circle::<span class="built_in">Circle</span>()<span class="comment">//构造函数定义</span></span><br><span class="line">{</span><br><span class="line">    radius=<span class="number">1.0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">double</span> r)<span class="comment">//构造函数定义</span></span><br><span class="line">{</span><br><span class="line">    radius=r;</span><br><span class="line">}</span><br><span class="line"><span class="function">doucle <span class="title">Circle::findarea</span><span class="params">()</span><span class="comment">//成员函数定义</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> radius*radius*<span class="number">3.14</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>定义类时应注意的问题</p><ul><li>使用private、protected和public保留字标识主体中每一区间的访问权限，同一保留字可以多次出现。</li><li>成员在类定义体中出现的顺序可以任意，函数成员的实现既可以放在类的外面，也可以内嵌在类定义体中（<strong>此时会自动成为内联函数</strong>）；但是数据成员的声明定义顺序与初始化顺序有关（<strong>先声明定义的先初始化</strong>）。</li><li>同一区间内可以有数据成员、函数成员和类型成员，习惯上按类型成员、数据成员和函数成员分开。</li><li>类的定义体花括号后要有分号作为定义体结束标志。</li><li>在类定义体中允许对数据成员定义默认值，若在构造函数的参数列表后面的<code>：</code>和函数体的<code>{</code>之间对其进行了初始化（在成员初始化列表进行初始化），则默认值无效，否则用默认值初始化；</li><li>构造函数和析构函数都不能定义返回类型。</li><li>如果类没有自定义的构造函数和析构函数，则C++为类生成默认的构造函数（不用给实参的构造函数）和析构函数。</li></ul><p>构造函数用来产生对象，为对象申请资源，初始化数据成员。构造函数是函数名与类名相同的函数成员，可以在参数表中显式定义参数，通过参数变化实现重载。定义变量或者其生命期开始时自动调用构造函数，由于一个对象仅自动构造一次，故构造函数不能被显式调用。</p><p>析构函数是用来毁灭对象的，释放对象申请的所有资源。析构函数的函数名与类名相同且带波浪线，参数表无参，无法重载。变量的生命期结束时会自动调用析构函数，析构函数可以显式调用，大师应当防止反复析构（自动变量不要显式调用析构函数，系统会自动调用，若析构函数没有防止反复释放资源显式调用可能会引起程序错误）</p><p>不同对象的析构与构造：</p><ul><li>全局对象：由开工函数构造，收工函数析构，储存在数据段里</li><li>静态局部变量：定义时自动构造，main函数执行完后由收工函数析构，储存在数据段里</li><li>局部自动变量：定义时自动构造，函数返回时自动析构，储存在堆栈里</li><li>new：调用new时自动构造，需要手动调用delete，储存在堆里</li></ul><p>程序不同结束形式对对象的影响：</p><ul><li><code>exit</code>：静态和全局变量会在main函数exit时由收工函数析构，其他变量都不会自动执行析构函数</li><li><code>abort</code>：所有对象都不会被析构</li><li><code>return</code>：除new出来的对象以外所有的对象都会按照既定方式自动调用析构函数。</li></ul><h3 id="成员访问权限及对成员的访问">成员访问权限及对成员的访问</h3><ul><li><code>private</code>：私有成员，本类函数成员可以访问；派生类函数成员、其他函数成员和普通成员都不能访问</li><li><code>protected</code>：保护成员：本类和派生类的成员函数可以访问，其他类成员和普通函数都不能访问</li><li><code>public</code>：共有成员，任何函数均可访问</li></ul><p>注意：</p><ol type="1"><li>类的友元可以访问类的所有成员函数</li><li>构造函数和析构函数可以定义为任何访问权限</li><li><code>class</code>定义的类中，缺省访问权限为<code>private</code>；<code>struct</code>和<code>union</code>定义的类冲缺省的访问权限为<code>public</code></li></ol><h3 id="内联匿名类和位段">内联，匿名类和位段</h3><p>在类体内定义的任何函数都会自动内联。当然用<code>inline</code>修饰的函数也会内联。匿名类（即类定义时没有名字）的函数成员只能在类体内定义（内联），函数的局部类成员也只能在类体内定义（内联）</p><p>没有对象的全局匿名联合必须定义为<code>static</code>，局部的匿名联合不能定义为<code>static</code>，匿名联合只能定义公有数据成员，vi是相当与定义了几个变量，但是这些变量公用存储空间。</p><p>位段的用法和C一样</p><h3 id="new和delete">new和delete</h3><p>C语言的内存管理使用<code>malloc</code>和<code>free</code>函数，C++使用<code>new</code>和<code>delete</code>运算符</p><p><code>new</code>：用法为<code>new 类型表达式{初始值}</code>，其中初始值可以用圆括号，也可以省略，在为数组分配内存时第一维下标可以为任意表达式，其他必须为常量表达式。 <code>new</code>的底层依然是调用<code>malloc</code>函数，因此对简单对象<code>new</code>和<code>malloc</code>没什么不同，与<code>malloc</code>不同的是<code>new</code>还会调用类的构造函数。</p><p><code>delete</code>：用法为<code>delete 指针</code>或者<code>delete[] 数组指针</code>前者只能用于销毁单个实体，后者可以用于销毁对象数组，其底层为先调用析构函数，再调用<code>free</code></p><h3 id="隐藏参数this">隐藏参数this</h3><p><code>this</code>指针是一个特殊的指针，它是普通函数成员（非静态函数成员）隐含的第一个参数，其类型是指向要调用该函数成员的对象的<code>const</code>指针。可以认为<code>this</code>指向这个类，可以用<code>this-&gt;</code>调用类的成员。<code>this</code>指针不允许移动</p><h3 id="对象的构造与析构">对象的构造与析构</h3><p><strong>非静态数据成员</strong>可以再如下位置初始化</p><ul><li>就地初始化，在定义类的数据成员的时候初始化赋值</li><li>成员初始化列表初始化</li><li>就地初始化与成员初始化列表同时使用时以初始化列表为准</li><li>赋值，即在构造函数体内赋值</li></ul><p>同样注意 <code>const</code>和引用类型变量定义时必须初始化,且只能就地初始化或者在成员初始化列表中初始化。</p><p>若未定义或生成构造函数，则可以用<code>{}</code>的形式初始化，这里和C的结构初始化是一样的。</p><p>若类未定义构造函数，编译器会尝试自动生成构造函数，成为<strong>合成的默认构造函数</strong>，一旦定义了构造函数，编译器生成的构造函数将不会被接受，除非用<code>default</code>。</p><p>合成的默认构造函数工作结果分为以下几种情况</p><ul><li>如果为数据成员提供了就地初始化，则工作成功</li><li>如果没有就地初始化<ul><li>若只包含非<code>const</code>、非应用内置数据类型成员，如果类的对象是全局或局部静态的，则这些成员默认初始化为0；如果类的对象是局部自动的，当程序访问这些成员时编译器报错，如果对象是new出来的，则不会报错，但访问结果是随机值</li><li>如果包含<code>const</code>，引用数据成员，其他无默认构造类型的<code>class</code>类型成员，一旦实例化对象，编译器报错</li></ul></li></ul><p>若自定义了构造函数之后仍要求编译器提供合成的默认构造函数，可以使用<code>构造函数名称()=default</code>来使用不带参的默认构造函数。</p><h3 id="转换构造函数">转换构造函数</h3><p>如果构造函数只接受一个实参，实际上它定义了转换为此类类型的转换机制，这种构造函数称为转换构造函数。如下面的例子</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span></span><br><span class="line">{</span><br><span class="line">    	<span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">integer</span>(<span class="type">int</span> value):<span class="built_in">value</span>(value){};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Integer i=<span class="number">25</span>;<span class="comment">//这里相当于隐式将int转换为Integer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>这里的隐式转换的原因就是我们在定义一个对象时由于其构造函数只就收一个变量，故可以用<code>=</code>将其初始化。注意这种转换只能进行一次，比如我们由下面的一个类</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Age</span></span><br><span class="line">{</span><br><span class="line">    	Integer age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Age</span>(Integer i):<span class="built_in">age</span>(<span class="number">0</span>){}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>我们无法在主函数中直接<code>Age a = 100</code>。</p><p>要避免这种隐式转换，可以在构造函数前面加上<code>explicit</code>,这样的话我们便不能用<code>=</code>对变量进行初始化，只能用<code>()</code></p><h3 id="拷贝构造函数">拷贝构造函数</h3><p>如果<code>class A</code>的构造函数的第一个参数是自身类型引用(<code>const A &amp;</code>或<code>A &amp;</code>), 且其它参数都有默认值（或没有其它参数），则此构造函数是拷贝构造函数。<strong>用一个已经构造好对象去构造另外一个对象时会调用拷贝构造函数</strong></p><p>如果没有为类定义拷贝构造函数，编译器会为我们定义一个合成的默认拷贝构造函数，编译器提供的合成的默认拷贝构造函数原型是<code>ACopyable(const ACopyable &amp;o</code>)，在没有自定义构造函数或者用了<code>default</code>之后可以直接使用。编译器提供的合成的默认拷贝构造函数其行为是：按成员依次拷贝。如果用类型A的对象<code>o1</code>拷贝构造对象<code>o2</code>，则依次将对象<code>o1</code>的每个非静态数据成员拷贝给对象<code>o2</code>的对应的非静态数据成员。</p><h4 id="浅拷贝">浅拷贝</h4><p>按成员依次拷贝称为浅拷贝。在浅拷贝过程中，若实参对象包含指针类型的实例数据成员，只复制指针值则两个对象的该成员指向同一块内存，可能会造成内存的错误。</p><h4 id="深拷贝">深拷贝</h4><p>在传递参数时先为形参对象的<strong>指针成员</strong>分配新的存储单元，而后将实参对象的指针成员所指向的单元内容复制到新分配的存储单元中。为了在传递参数时能进行深拷贝，<strong>必须自定义参数类型为类的引用</strong>的拷贝构造函数，即定义<code>A (A &amp;)</code>、<code>A (const A&amp;)</code> 等形式的构造函数。建议使用<code>A (const A&amp;)</code>。</p><p>如上面转换构造函数中提到的，单参数构造函数可以用<code>=</code>调用，当我们没有自定义<code>=</code>重载时，编译器会提供一个重载，但此时为浅拷贝构造。因此安全的做法是在自定义深拷贝构造函数后还要自己实现<code>=</code>运算符的深拷贝重载</p><h4 id="移动构造和移动赋值">移动构造和移动赋值</h4><p>当函数的参数为值参以及函数返回类型为值时，都会出现对象的频繁拷贝。在很多情况下，对象被拷贝后就立即销毁（特别是函数返回值时），在这些情况下，采用移动对象会大幅提高性能。所谓移动构造和移动赋值，就是将对象的指针指向实参指向的空间，然后将实参进入安全可析构的状态。</p><p>移动构造的本质是浅拷贝，但与浅拷贝不同的是由于实参是马上要被销毁的对象，因此我们可以对其随意更改，所以我们将实参的指针设为空指针，使其析构时不会释放其指向的内存。</p><p>如果一个类既有拷贝构造函数，也有移动构造函数，编译器根据参数类型进行匹配来确定使用哪个构造函数，赋值操作类似。因此这时遵循一个重要原则：移动右值，拷贝左值。若没有移动构造/移动赋值函数，右值也被拷贝构造/拷贝赋值。</p><p>前面提到过可以用<code>=default</code>来显式要求编译器提供默认版本，还可以用<code>=delete</code>定义为删除</p><h2 id="第五章-成员及成员指针">第五章 成员及成员指针</h2><p>成员指针：指向类的成员（普通和静态成员）的指针，分为实例成员指针和静态成员指针。变量、数据成员、函数参数和返回类型都可定义为成员指针类型, 即普通指针能用的地方成员指针都能用。例如<code>int A::*p</code>即指向<code>A</code>类的<code>int</code>类型的实例数据成员。可将其赋值为<code>p=&amp;A::m</code></p><p>利用指针访问类的成员使用<code>.*</code>或者<code>-&gt;*</code>运算符，用法为<code>对象名.*指针名</code>或<code>对象指针-&gt;*指针名</code></p><p><strong>注意这是指向类的成员的指针，不是指向实例化了的对象的成员的指针</strong></p><h3 id="实例成员指针">实例成员指针</h3><p>实例成员指针是指向实例成员的指针，可分为实例数据成员指针和实例函数成员指针。由于构造函数不能被显式调用，故不能有指向构造函数的实例成员指针。</p><p>实例成员指针式数据成员相对于对象首地址的偏移，<strong>不是真正的地址</strong>，所以实例成员指针不能移动，也不能转换类型。</p><p><em>其实很好理解，实例成员指针指向的是类的成员，没有实例化的时候绝对地址没有意义，所以记录的是相对地址。由于数据成员的大小，访问权限类型不一定相同，轻易移动指针很可能会出现问题。类型转换也是，若对指针进行类型转换其实相当于移动了指针</em></p><h3 id="constvolatile和mutable">const、volatile和mutable</h3><p><code>const</code>只读、<code>volatile</code>易变、<code>mutable</code>机动，前两者可以用来定义变量，类的数据成员、函数成员以及普通函数的参数和返回值，最后一个只能用来定义类的数据成员。含<code>const</code>的数据成员的类必须定义有初始化，<code>volatile</code> <code>mutable</code> 则不一定</p><p>关于这三个关键字在修饰类的成员时，应注意以下几点</p><ul><li>普通函数<strong>成员参数表后</strong>出现<code>const</code>或<code>volatile</code>，<strong>修饰隐含参数</strong><code>this</code><strong>指向的对象</strong>。<ul><li>出现<code>const</code>表示<code>this</code>指向的对象的非只读类型的静态数据成员可以修改，但不能修改调用对象的非静态数据成员，但如果该数据成员的存储类为mutable，则该数据成员就可以被修改。</li><li>出现volatile，常表示调用该函数成员的对象是挥发对象，这通常意味着存在并发执行的进程。</li><li>mutable说明数据成员为机动数据成员，该成员不能用const、volatile或static修饰。</li></ul></li><li><code>const</code> <code>volatile</code>对隐含参数的修饰还会影响函数成员的重载<ul><li>普通对象应调用参数表后不带const和volatile的函数成员；</li><li>const和volatile对象应分别调用参数表后出现const和volatile的函数成员，否则编译程序会对函数调用发出警告。</li></ul></li></ul><h3 id="静态数据成员">静态数据成员</h3><p>静态成员用<code>static</code>声明, 包括静态数据成员和静态函数成员，<code>static</code>声明<strong>只能出现在类内</strong>。<em>即别在类外实现函数的时候出现inline</em></p><p>非<code>const</code>、非<code>inline</code>静态数据成员在<strong>类体内声明</strong>、<strong>类体外定义并初始化</strong>。<code>const</code> <code>inline</code>修饰的静态数据成员可以在类内就地初始化</p><p>类的静态数据成员<strong>在类还没有实例化对象前就已存在</strong>，相当于Java的类变量，用于描述类的总体信息，如对象总数、连接所有对象的链表表头等。访问权限同普通成员。逻辑上，所有对象共享静态数据成员内存，任何对象修改静态数据成员的值，都会同时影响其他对象关于该成员的值。物理上，静态数据成员相当于独立分配内存的变量，不属于任何对象内存的一部分。<strong>静态数据成员相当于有类名限定、带访问权限的全局变量</strong></p><h3 id="静态函数成员">静态函数成员</h3><p>静态函数成员通常在类内以<code>static</code>说明或定义，没有<code>this</code>参数。因此有<code>this</code>的构造和析构函数、虚函数以及纯虚函数都不能定义为静态函数成员。</p><p>由于没有<code>this</code>参数，静态函数成员参数表后不能用<code>const</code>、<code>volatile</code>、<code>const</code> <code>volatile</code>等修饰符修饰。静态函数成员也不能访问对象的非静态成员函数</p><h3 id="静态成员指针">静态成员指针</h3><p>静态成员指针是指向类的静态成员的指针，包括静态数据成员指针和静态函数成员指针。</p><p>由于静态成员是在没有实例化对象前就已经存在了的，所以是有地址的，因此<strong>指向静态成员指针就用普通指针</strong></p><h2 id="第六章-继承与构造">第六章 继承与构造</h2><p>继承是C++类型演化的重要机制，在保留原有类的属性和行为的基础上，派生出的新类可以有某种程度的变异。接受成员的新类称为派生类，提供成员的原有类型称为基类。</p><p>C++既支持单继承又支持多继承。单继承只能获取一个基类的属性和行为。多继承可获取多个基类的属性和行为。</p><h3 id="单继承类">单继承类</h3><p>单继承是只有一个基类的继承方式。单继承的定义格式为</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名</span><br><span class="line">{</span><br><span class="line">    派生类新成员定义</span><br><span class="line">    派生类重新定义基类同名的数据和函数成员</span><br><span class="line">    派生类声明修改基类成员访问权限</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="继承方式">继承方式</h3><p>继承方式指明派生类采用什么继承方式从基类获得成员，分为三种：<code>private</code>表示私有继承基类；<code>protected</code>表示保护继承基类；<code>public</code>表示公有继承基类。 三种继承方式派生类对基类成员的访问权限为</p><ol type="1"><li>基类私有成员对派生类函数是不可见的。派生类不能访问基类私有成员，除非将派生类的声明为基类的友元类，或者将要访问基类私有成员的派生类函数成员声明为基类的友元。</li><li>公有继承时基类的公有成员和保护成员派生到派生类时都保持原有的状态</li><li>保护继承时基类的公有成员和保护乘员都称为派生类的保护乘员</li><li>私有继承时基类的功有成员和保护成员派生后都作为派生类的私有成员</li></ol><p>用<code>class</code>声明的类的继承方式缺省为<code>private</code>，用<code>struct</code>声明的继承方式和访问权限缺省为<code>public</code>。用<code>union</code>声明的类既不能作派生类的基类，也不能作任何基类的派生类。</p><p>派生类可以通过<code>using 基类名::基类成员</code>或者直接<code>基类名::基类成员</code>来改变访问权限，如：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b,c;</span><br><span class="line">    <span class="type">int</span> bb;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> d,e;</span><br><span class="line">    <span class="type">int</span> cc;</span><br><span class="line">   ~<span class="built_in">A</span>() {};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">protected</span> A{</span><br><span class="line">     <span class="type">int</span> a; </span><br><span class="line">     A::cc; <span class="comment">// using A::cc;降低</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b,f;       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> e,g;</span><br><span class="line">    <span class="keyword">using</span> A::d; <span class="comment">//恢复</span></span><br><span class="line">    A::bb；<span class="comment">//提升</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><p>标识符的作用范围可分为从小到大四种级别：①作用于函数成员内；②作用于类或者派生类内；③作用于基类内；④作用于虚基类内。 标识符的作用范围越小，被访问到的优先级越高。如果希望访问作用范围更大的标识符，则可以用类名和作用域运算符进行限定。</p><h3 id="构造与析构">构造与析构</h3><p>单继承派生类的构造顺序为：</p><ol type="1"><li>调用虚基类的构造函数</li><li>调用基类的构造函数</li><li>按照派生类中数据成员的声明顺序，依次调用数据成员的构造函数或初始化数据成员</li><li>调用派生类的构造函数</li></ol><p>析构是构造的逆序。</p><p>析构时应该注意：</p><ol type="1"><li>如果被引用的对象是<code>new</code>生成的，引用变量必须用<code>delete &amp;r</code>析构</li><li>若被指针指向的对象是<code>new</code>生成的，则指针变量必须用<code>delete p</code>析构，不能用<code>free(p)</code></li></ol><h3 id="父类与子类">父类与子类</h3><p>如果派生类的继承方式位为<code>public</code>，则这样的派生类称为基类的子类，而相应的基类则称为派生类的父类。</p><p>C++允许父类指针直接指向子类对象，也允许父类引用直接引用子类对象。编译程序只能根据类型定义静态地检查语义。由于父类指针可以直接指向子类对象，而到底是指向父类对象还是子类对象只能在运行时确定。编译时，只能把父类指针指向的对象都当作父类对象。因此编译时父类指针访问对象的数据成员或函数成员时不能超越父类为其相应对象规定的访问权限，也不能通过父类指针访问子类新增的成员。</p><p>子类指针指向父类对象时要经过强制类型转换。</p><h2 id="第七章-可访问性">第七章 可访问性</h2><h3 id="作用域-1">作用域</h3><p>作用域：标识符起作用的范围。作用域运算符<code>::</code>既是单目运算符，又是双目运算符。其优先级和结合性与括号相同。单目用于限定全局标识符，双目用于限定类的枚举元素、数据成员、函数成员以及类型成员等。双目运算符还用于限定名字空间成员，以及恢复从基类继承的成员的访问权限。</p><p>面向对象的编程中作用域大小前面说过了</p><h3 id="名字空间">名字空间</h3><p>名字空间是C++引入的一种新作用域，C++名字空间既面向对象又面向过程：除可包含类外，还可包含函数、变量定义。</p><p>名字空间必须在全局作用域内用namespace定义，不能在类、函数及函数成员内定义，最外层名字空间名称必须在全局作用域唯一。同一名字空间内的标识符名必须唯一，不同名字空间内的标识符名可以相同。当程序引用多个名字空间的同名成员时，可以用名字空间加作用域运算符<code>::</code>限定。</p><p>名字空间(包括匿名名字空间)可以分多次定义（在不同文件里）：</p><ul><li>可以先在初始定义中定义一部分成员，然后在扩展定义中再定义另一部分成员；</li><li>或者先在初始定义中声明的函数原型，然后在扩展定义中再定义函数体；</li></ul><p>所谓扩展定义其实和初始定义一样，只是分了几次说而已。</p><p>名字空间成员有三种访问方式：</p><ul><li>直接访问：<code>名字空间名称::成员名称</code></li><li>引用成员：<code>using 名字空间名称::成员名称</code>，引用时只能给出函数名，不能带函数参数。<em>引用其实相当于extern声明，直接访问则是直接加个前缀就开始用</em></li><li>引用名字空间：<code>using namespace 名字空间名称</code></li></ul><p><code>using</code>声明以关键字<code>using</code>开头，后面是名字空间成员名, 如果是声明嵌套多层的名字空间里的成员，要多级限定。如果<code>using</code>直接引用了成员，则在当前作用域下不能再定义同名变量；若引用的是整个名字空间，假设在当前作用域下定义了与名字空间中某个成员重名的变量，在未使用同名变量前不会报错，一旦在没有加上限定符的情况下就使用会报错。</p><p>嵌套名字空间：名字空间内可定义名字空间，形成多个层次的作用域，引用时多个作用域运算符自左向右结合。如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A {	<span class="comment">// A的初始定义     </span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;     </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">( )</span> </span>{ <span class="keyword">return</span>  <span class="number">6</span>; }     </span><br><span class="line">    <span class="keyword">namespace</span> B { <span class="type">int</span> y = <span class="number">8</span>, z = <span class="number">9</span>; }     </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> B; } </span><br><span class="line"><span class="keyword">using</span> A::x;     	<span class="comment">//特定名字空间成员using声明，不能再定义变量x </span></span><br><span class="line"><span class="keyword">using</span> A::f;     	<span class="comment">//特定名字空间成员using声明，不能再定义函数f </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A::B;	<span class="comment">//非特定成员using，可访问A::B::y, A::B::z,还可重新定义 </span></span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;		<span class="comment">//定义全局变量y </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{     </span><br><span class="line">    <span class="built_in">f</span>( );		<span class="comment">//调用A::f( )     </span></span><br><span class="line">    A::<span class="built_in">f</span>( );		<span class="comment">//调用A::f( )     </span></span><br><span class="line">    ::A::<span class="built_in">f</span>( );	<span class="comment">//调用A::f( )     </span></span><br><span class="line">    cout&lt;&lt;x+ ::y + z + A::B::y; <span class="comment">//同一作用域有两个y,必须区分 </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>可以为名字空间定义别名，以代替过长和多层的名字空间名称。对于嵌套定义的名字空间，使用别名可以大大提高程序的可读性。如<code>namespace AB=A::B</code></p><p>匿名名字空间：匿名名字空间的作用域为当前程序文件，名字空间被自动引用，其成员定义不加入当前作用域（面向过程或面向名字空间），即可以在当前作用域定义同名成员。<strong>一旦同名冲突，自动引用的匿名名字空间的成员将是不可访问的</strong>。 在同一个文件里，匿名名字空间也可分多次定义。</p><h3 id="成员友元">成员友元</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有成员和保护成员。**要声明一个函数为一个类的友元，则在该类中用<code>friend</code>声明该函数即可，函数的实现放在类外。</p><p>成员友元是一种将一个类的函数成员声明为其它类友元的函数。</p><p>如果类A的实例函数成员被声明为类B的成员友元，则这种友元称为实例成员友元。如果类A的静态函数成员被声明为类B的成员友元，则这种友元称为静态成员友元。</p><p>如果某类A的所有函数成员都是类B的友元，则可以简单的在B的定义体内用friend A;声明，不必列出A的所有函数成员。此时称类A为类B的友元类。</p><p><strong>友元的派生不具有传递性和对称性</strong></p><h3 id="普通友元及其注意事项">普通友元及其注意事项</h3><p>包括主函数在内任何一个普通函数都可以定义为一个类的普通成员友元。普通友元不是类的函数成员，故普通友元可在类的任何访问权限下定义。一个普通函数可以定义为多个类的普通友元。</p><h2 id="第八章-虚函数与多态">第八章 虚函数与多态</h2><h3 id="虚函数">虚函数</h3><p>虚函数是用<code>virtual</code>定义的实例成员函数。当基类对象指针或引用指向或引用不同类型的派生类对象时，通过虚函数到基类或派生类中同名函数的映射实现动态多态。静态多态与动态多态的概念在第一章中有论述。下面是一个例子</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{ </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “A\n”); }   </span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A{ </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “B\n”); }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B{ </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “C\n”); }</span><br><span class="line">};</span><br><span class="line"><span class="comment">//现在编写全局函数，使其能够打印A、B、C类对象的信息，使用函数重载的静态多态实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInfo</span> <span class="params">(A* a)</span> </span>{ a-&gt;<span class="built_in">info</span>( );}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInfo</span> <span class="params">(B* b)</span> </span>{ b-&gt;<span class="built_in">info</span>( );}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInfo</span> <span class="params">(C* c)</span> </span>{ c-&gt;<span class="built_in">info</span>( );}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A*p=<span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">PrintInfo</span>(p);<span class="comment">//此时调用第一个PrintInfo，如果想要调用其他的PrintInfo需要传入不同类型的指针。如果再派生一个子类D出来则需要重新编写一个新的重载函数</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{ </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “A\n”); } </span><br><span class="line"> 	<span class="comment">//首先将info定义为虚函数 </span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A{ </span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “B\n”); }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B{ </span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">info</span><span class="params">()</span> </span>{ cout &lt;&lt; “C\n”); }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInfo</span> <span class="params">(A *p)</span> </span>{ p -&gt;<span class="built_in">info</span>(); } <span class="comment">//形参定义为顶级父类指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>( ); B *b = <span class="keyword">new</span> <span class="built_in">B</span>( ); C *c = <span class="keyword">new</span> <span class="built_in">C</span>( );</span><br><span class="line">    <span class="built_in">PrintInfo</span> (a);  	<span class="comment">//调用A的info，显示A。A * p = a;</span></span><br><span class="line">    <span class="built_in">PrintInfo</span> (b); 		<span class="comment">//调用B的info，显示B。 A *p = b；</span></span><br><span class="line">    <span class="built_in">PrintInfo</span> (c); 		<span class="comment">//调用C的info，显示C。 A *p = c;</span></span><br><span class="line">    <span class="comment">//此时若派生出新的子类D，PrintInfo函数不需要做任何修改就可以直接用</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>注意：只有基类的指针或者引用才能体现出多态，这里的多态指的指针对基类的对象设计的代码可以应用于子类对象，调用的方法时最具体的类的方法</strong></p><p>关于虚函数，有以下几个需要注意的问题</p><ul><li><p>虚函数必须是类的实例成员函数，非类的成员函数不能说明为虚函数，普通函数如<code>main</code>不能说明为虚函数。</p></li><li><p>虚函数一般在基类的<code>public</code>或<code>protected</code>部分</p></li><li><p>在派生类中重新定义成员函数时，<strong>函数原型必须完全相同</strong>；</p></li><li><p>虚函数只有在具有继承关系的类层次结构中定义才有意义，否则引起额外开销 (需要通过VFT访问)</p></li><li><p>一般用父类指针(或引用)访问虚函数。根据父类指针所指对象类型的不同，动态绑定相应对象的虚函数</p></li><li><p>虚函数有隐含的this参数，参数表后可出现<code>const</code>和<code>volatile</code></p></li><li><p>构造函数构造对象的类型是确定的，不需根据类型表现出多态性，故不能定义为虚函数；析构函数可通过父类指针(引用)或<code>delete</code>调用，父类指针指向的对象类型可能是不确定的，因此析构函数可定义为虚函数（强烈建议,<strong>当然此时函数原型不相同，不过没有问题</strong>）。</p></li><li><p>一旦父类(基类)定义了虚函数，所有派生类中原型相同的非静态成员函数自动成为虚函数（即使没有<code>virtual</code>声明）；(虚函数特性的无限传递性)</p></li><li><p>多态并不是只有父子关系之间有，若类之间的继承关系不是父子关系，其影响只是基类指针不能指向派生类的对象，指针或地址强制类型转换后多态性质依然成立</p></li><li><p>用父类引用实现动态多态性时需要注意，<code>new</code>产生的被引用对象必须用<code>delete &amp;</code>析构,而不能仅仅调用析构函数或者使用<code>free</code></p></li></ul><h3 id="抽象类">抽象类</h3><p>纯虚函数：指不必定义函数体的函数，可以有重载、缺省参数、省略参数、内联等。定义格式为<code>virtual 函数原型 = 0</code>。纯虚函数也有<code>this</code>指针，不能定义为<code>static</code>。纯虚函数的函数体应在派生类中实现，成为非纯虚函数。</p><p>含有纯虚函数的类称为抽象类。抽象类不应该有对象或类的实例。如果抽象类的派生类继承了抽象类的纯虚函数却没有实现，则该派生类依然为抽象类。只有在派生过程中所有纯虚函数都被实现，派生类才会成为非抽象类。</p><p>抽象类作为抽象级别最高的类，主要用于定义派生类共有的数据和函数成员。抽象类的纯虚函数没有函数体，意味目前尚无法描述该函数的功能。</p><h2 id="第九章-多继承类与虚基类">第九章 多继承类与虚基类</h2><h3 id="多继承">多继承</h3><p>多继承派生类有多个基类或虚基类。单继承是多继承的一种特例，多继承具有更强的类型表达能力。多继承派生类继承所有基类的数据成员和函数成员。</p><p>基类之间的成员可能同名，基类与派生类的成员也可能同名。在出现同名时，如面向对象的作用域不能解析，可使用基类类名加作用域运算符::来指明要访问基类的成员。</p><p>单继承语言在描述多继承的对象时，常常通过对象成员委托（代理）实现多继承。即继承一个类，然后将另一个类的数据对象作为数据成员，作为另一个类的行为的代理。</p><p>多继承方式定义派生类</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:派生方式 基类<span class="number">1</span>，派生方式 基类<span class="number">2</span></span><br><span class="line">{</span><br><span class="line">	类体</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>关于多继承有以下几个需要注意的问题</p><ul><li>一个类不能多次成为一个派生类的直接基类（即使是虚基类） 否则会报编译错误</li><li>一个类可以多次成为一个派生类的间接基类（即使不是虚基类）</li><li>一个类可以同时成为一个派生类的直接基类和间接基类，但该类作为直接基类时必须是虚基类。 否则会报警告错误</li></ul><p>直接多继承和委托代理可能存在一个问题，如果两个基类在物理上存在同一个基类，可能对同一个物理对象重复初始化以及重复析构。</p><h3 id="虚基类">虚基类</h3><p>虚基类用virtual声明，可把多个逻辑虚基类对象映射成同一个物理虚基类对象。映射成的这个物理虚基类对象<strong>尽可能早的构造、尽可能晚的析构</strong>，<strong>且构造和析构都只进行一次</strong>。</p><p>假设两栖机车<code>AmphibiousVehicle</code>继承基类陆用机车<code>LandVehicle</code>和水上机车<code>WaterVehicle</code>，<code>LandVehicle</code>和<code>WaterVehicle</code>都继承自<code>Engine</code>，则在构造时可能会对<code>AmphibiousVehicle</code>的 <code>Engine</code>初始化两次</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129103416061.png" alt="未引入虚基类"></p><p>使用虚基类<code>Engine</code>,之后<code>LandVehicle</code>和<code>WaterVehicle</code>的<code>Engine</code>都指向同一块物理内存，且只会构造和析构一次，则不会出现上述情况。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129103924426.png" alt="使用虚基类"></p><p>代码如下:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接多继承</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Engine</span>{ <span class="comment">/*...*/</span>}; </span><br><span class="line"> 	<span class="keyword">class</span> <span class="title class_">LandVehicle</span>: Engine{<span class="comment">/*...*/</span>}; </span><br><span class="line"> 	<span class="keyword">class</span> <span class="title class_">WaterVehicle</span>: Engine{<span class="comment">/*...*/</span>}; </span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">AmphibiousVehicle</span>:<span class="keyword">public</span> LandVehicle,<span class="keyword">public</span> WaterVehicle{<span class="comment">/*...*/</span>} ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用虚基类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Engine</span>{ <span class="comment">/*...*/</span> }; </span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">LandVehicle</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> Engine{ <span class="comment">/*...*/</span> }; </span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WaterVehicle</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> Engine{ <span class="comment">/*...*/</span> }; </span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">AmphibiousVehicle</span>: <span class="keyword">public</span> LandVehicle, <span class="keyword">public</span> WaterVehicle{  }; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>同一棵派生树中的同名虚基类，共享同一个存储空间；其构造和析构仅执行1次，且构造尽可能最早执行，而析构尽可能最晚执行。由派生类（根） 、基类和虚基类构成一个派生树的节点，而对象成员将成为一棵新派生树的根。</p><p>在非虚拟派生中，派生类只能显式初始化其<strong>直接基类</strong>，而虚拟基类的初始化则成了<strong>每一级派生类的责任</strong>，即只要使用了虚基类，虚基类的每一级派生类都必须调用虚基类的构造函数（因为虚基类必须最先构造），有虚基类的派生类构造函数不能使用<code>constexpr</code>定义</p><h3 id="派生类成员">派生类成员</h3><p>虚基类和基类成员同名必然会导致二义性访问，编译程序会对这种二义性访问报错。当出现这种情况时，可用作用域运算符限定要访问的成员。</p><p>当派生类成员和基类成员同名时，优先访问作用域小的成员，即优先访问派生类的成员。当派生类数据成员和派生类函数成员的参数同名时，在函数成员内优先访问函数参数。</p><h3 id="多继承的构造与析构">多继承的构造与析构</h3><p>派生类对象的构造顺序：</p><ul><li>按定义顺序构造派生树中所有虚基类</li><li>按定义顺序构造派生类中所有直接基类</li><li>按定义顺序构造派生类数据成员</li><li>执行派生类构造函数</li></ul><p>析构顺序与构造顺序相反。注意：<strong>同名派生类在同一棵树中只构造一次</strong></p><h2 id="第十章-异常与断言">第十章 异常与断言</h2><h3 id="异常处理">异常处理</h3><p>异常时一种意外破坏程序正常处理的时间、由硬件或软件触发的事件。异常处理可以将错误处理流程同正常业务处理流程分离，从而使程序的正常业务处理流程更加清晰顺畅。</p><p>异常发生后自动析构调用链中的所有对象，这也使程序降低了内存泄漏的风险。 由软件引发的异常用<code>throw</code>语句抛出，会在抛出点建立一个描述异常的对象，由<code>catch</code>捕获相应类型的异常。</p><p>异常处理的一般结构为：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    <span class="comment">/*程序的正常流程部分*/</span></span><br><span class="line">    <span class="keyword">throw</span> expression1;<span class="comment">//throw可以抛出任意类型的异常，包括字符、字符串、数组、对象</span></span><br><span class="line">    <span class="comment">/*继续接程序的正常流程部分*/</span></span><br><span class="line">    <span class="keyword">throw</span> expression2;<span class="comment">//一个try种可以抛出多个异常。但是值啊要抛出第一个异常，try语句块马上结束，转到catch自居。如果try语句块执行成功，则跳过catch</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span>(expression1){<span class="comment">//catch子句必须定义且只能定义一个参数，即接受的异常，该参数不能是void，不能是右值引用。</span></span><br><span class="line">    <span class="comment">/*对异常的处理*/</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span>(expression2){</span><br><span class="line">    <span class="comment">/*对异常的处理*/</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//可定义多个catch子句截获可能抛出的各种异常。但最多只会执行其中一个异常处理过程。在相应异常被处理后，其他异常处理过程都将被忽略。如果异常处理成功，则执行后续statements。如果异常处理过程中又抛出新的异常，则后续statements不会被执行</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p><code>catch</code>必须出现<code>try</code>语句块后面，不能有单独的<code>try</code>语句块或者单独的<code>catch</code>语句块，<code>throw</code>语句要求直接或者间接出现在try语句块中,异常必须被某个<code>try</code>的<code>catch</code>捕获。如果没有被任何<code>catch</code>捕获，则程序将被终止执行。</p><p>异常捕获的过程称为栈展开，即当<code>try</code>语句快有异常抛出时，先检查该<code>try</code>语句的相关<code>catch</code>子句，没找到则检查外层<code>try</code>自居配套的<code>catch</code>子句，还没找到则退出当前函数，在调用该函数的外层函数继续寻找，如果到主函数种还没找到catch自居，程序退出，将异常交给OS处理。以上过程递归调用，称为栈展开。</p><p>如果在<code>catch</code>子句中需要重新抛出异常，可以直接使用不带表达式的<code>throw</code>语句用以传播已捕获的异常。若希望捕获所有异常，则可以使用<code>catch(...)</code>。若接受的异常类型为字符串常量，则需要用<code>catch(const char *p)</code>捕获。</p><h3 id="捕获顺序">捕获顺序</h3><p>总的来说，先声明的异常处理先得到执行机会。特别的，异常的类型只要和<code>catch</code>参数的类型相同或相容即可匹配成功。即派生异常对象(及对象指针或引用)可以被带基类型对象、指针及引用参数的<code>catch</code>子句捕获。注意<code>catch(const volatile void *)</code>能捕获任意指针类型的异常，<code>catch(…)</code>能捕获任意类型的异常。</p><h3 id="函数的异常接口">函数的异常接口</h3><p>通过异常接口声明的异常都是由该函数引发的、而其自身又不想捕获或处理的异常。 异常接口定义的异常出现在函数的参数表后面，用<code>throw</code>列出要引发的异常类型。其中<code>throw()</code>、<code>noexcept</code>、<code>throw(void)</code>代表不引发任何异常，如果参数表后面不出现异常接口，表示该函数可能引发任何类型的异常。</p><p>对于未经处理的异常或传播后未经处理的异常，C++的监控系统将调用<code>void terminate( )</code>处理。缺省情况下<code>terminate</code>函数调用<code>abort</code>函数来终止程序。可以调用<code>set_terminate( )</code>函数，设置自定义的terminate处理函数。如下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*old_terminate)();<span class="comment">//缺省的teminate函数主要是后面用来恢复</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">new_terminate</span><span class="params">()</span></span>{<span class="comment">//自定义的teminate函数，注意函数返回值为void</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Custom terminate"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">	<span class="built_in">f5</span>();           <span class="comment">//声明不会抛出异常，但实际抛出了异常，异常不会被截获</span></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">catch</span>(A &amp;ex){ cout &lt;&lt; ex.msg;}</span><br><span class="line">    <span class="built_in">catch</span>(B &amp;ex){ cout &lt;&lt; ex.msg;}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    old_terminate = <span class="built_in">set_terminate</span>(new_terminate);<span class="comment">//调用set_terminate函数，传入一个函数指针覆盖系统默认的terminate函数</span></span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">    <span class="comment">//如果程序运行到这里，说明没有异常</span></span><br><span class="line">    <span class="comment">//恢复终止处理函数set_terminate (old_terminate);</span></span><br><span class="line">    <span class="built_in">set_terminate</span> (old_terminate);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h3 id="断言">断言</h3><p>函数<code>assert(int)</code>在<code>assert.h</code>中定义。 断言是一个带有整型参数的用于调试程序的函数，如果实参的值为真则程序继续执行。 否则，将输出断言表达式、断言所在代码文件名称以及断言所在程序的行号，然后调用<code>abort()</code>终止程序的执行。</p><p>保留字<code>static_assert</code>定义的断言在编译时检查，为真时不终止编译运行。</p><h2 id="第十一章-运算符重载">第十一章 运算符重载</h2><h3 id="运算符概述">运算符概述</h3><p>运算符分为纯单目运算符，纯双目运算符，三目运算符，既是单目又是双目运算符，多目运算符。根据运算结果又可以分为左值运算符和右值运算符。</p><p>C++用<code>返回类型 operator 运算符(参数表)</code>进行运算符重载。如果用类的普通成员函数重载运算符，<code>this</code>隐含参数代表第一个操作数对象。</p><p>不能重载的运算符有:<code>sizeof</code> <code>.</code> <code>.*</code> <code>::</code> <code>?:</code></p><p>其他运算符能否重载的情况如下图所示</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20201129152651973.png" alt="运算符重载"></p><p>运算符重载基本和函数重载一样，但是由于运算符本身时有意义的，有以下几点要注意</p><ul><li>若运算符为左值运算符，则重载后运算符函数最好返回非只读左值引用类型(左值)。当运算符要求第一个参数为左值时，不能使用<code>const</code>说明第一个参数(含<code>this</code>)，例如<code>++</code>、<code>--</code>、<code>=</code>、<code>+=</code>等的第一个参数。</li><li>重载一般也不改变运算符的操作数个数。特殊的运算符<code>-&gt;</code>、<code>++</code>、<code>--</code> （区分前置和后置）除外。</li><li>重载不改变运算符的优先级和结合性。</li></ul><h3 id="运算符参数">运算符参数</h3><p>重载函数种类不同，参数表列出的参数个数也不同。</p><ul><li>重载为普通函数(全局函数）：参数个数=运算符目数</li><li>重载为类的普通成员函数（实例函数）：参数个数=运算符目数 - 1 (即<code>this</code>指针)</li><li>重载为类的静态成员函数：参数个数 = 运算符目数(没有this指针)</li></ul><h3 id="特殊运算符的重载">特殊运算符的重载</h3><ul><li>重载<code>++</code>，<code>--</code>：参数应设为非<code>const</code>左值引用，前置返回值为左值引用，后置返回值为右值。后置的参数应加上一个<code>int</code>类型表示后置</li><li>也可以用<code>operator</code>定义强制类型转换函数。由于转换后的类型就是函数的返回类型，所以强制类型转换函数不需要定义返回类型。</li></ul><h2 id="第十二章-类型解析转换和推导">第十二章 类型解析，转换和推导</h2><h3 id="显式与隐式类型转换">显式与隐式类型转换</h3><p>字节数少的类型向字节数多的类型转换时，不会引起数据的精度损失。 无风险的转换由编译程序自动完成，这种自动转换也称为隐式类型转换。强制类型转换称为显式类型转换</p><p>一般简单类型之间的强制类型转换的结果为右值，而进行左值引用转换时结果为左值。注意只读的简单类型变量如果转化为可写左值，依然不能修改其值，而对类的只读类型成员则可以（就离谱）</p><h3 id="cast系列类型转换">cast系列类型转换</h3><ul><li><p><code>static_cast</code>同C语言的强制类型转换用法基本相同，但不能从源类型中去除<code>const</code>和<code>volitale</code>属性，不做多态相关的检查。</p></li><li><p><code>const_cast</code>同C语言的强制类型转换用法基本相同，但能从源类型中去除<code>const</code>和<code>volitale</code>属性。</p></li><li><p><code>dynamic_cast</code>主要用于有继承关系的基类型和派生类型之间的相互转换。将子类对象转换为父类对象时无须子类多态，而将基类对象转换为派生类对象时要求基类多态。</p></li><li><p><code>reinterpret_cast</code>通常为运算对象的位模式提供低层级的重新解释。主要用于名字（运算对象）同指针或引用类型之间的转换，以及指针与足够大的整数类型（能够存放地址）之间的转换。</p></li></ul><h4 id="static_cast静态转换">static_cast——静态转换</h4><p>使用格式为<code>static_cast&lt;T&gt; (expr)</code>，如</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x=<span class="number">2.0</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(x);</span><br></pre></td></tr></table></figure></div><p>目标类型<code>T</code>不能包含存储位置类修饰符，如<code>static</code>、<code>extern</code>、<code>auto</code>、<code>register</code>等。 <code>static_cast</code>仅在编译时静态检查源类型能否转换为<code>T</code>类型，运行时不做动态类型检查。<code>static_cas</code>t不能去除源类型的<code>const</code>或<code>volatile</code>。即不能将指向<code>const</code>或<code>volatile</code>实体的指针(或引用)转换为指向非<code>const</code>或<code>volatile</code>实体的指针(或引用)。 只要不转换底层<code>const</code>(和指针与引用等复合类型的基本类型有关。修饰基本类型的<code>const</code>)，都可以使用<code>static_cast</code>。即我们无法通过修改指针类型以修改只读变量的值。</p><h4 id="const_cast只读转换">const_cast——只读转换</h4><p>使用格式与<code>static_cast</code>一致，但其目标类型必须是指针或引用或指向对象类型成员的指针。可以去掉指针顶层和底层的<code>const</code>和<code>volatile</code>，但不能改变其类型。</p><h4 id="dynamic_cast动态转换">dynamic_cast——动态转换</h4><p>关键字<code>dynamic_cast</code>主要用于子类向父类转换，以及<strong>有虚函数的基类</strong>向派生类转换。被转换的表达式必须涉及类类型。 使用格式为<code>dynamic_cast&lt;T&gt; (expr)</code>，要求<code>T</code>是类的引用、类的指针或者<code>void*</code>类型，而<code>expr</code>的源类型必须是类的对象（包括常量对象或变量对象：向引用类型转换）、父类或者子类的引用或指针。 <code>dynamic_cast</code>转换时不能去除数值表达式<code>expr</code>源类型中的<code>const</code>和<code>volitale</code>属性。 被转换的基类对象必须包含虚函数或纯虚函数才能转换为派生类对象。</p><h4 id="reinterpret_cast重释转换">reinterpret_cast——重释转换</h4><p>关键字<code>reinterpret_cast</code>实现有址表达式（有名字）到指针或(有址或无址)引用类型的转换以及指针与足够大整数类型间的相互转换。 使用格式为<code>reinterpret_cast &lt;T&gt; (expr)</code>，用于将数值表达式<code>expr</code>的值转换成<code>T</code>类型的值。<code>T</code>类型不能是实例数据成员指针。 转换为足够大的整数类型是指能够存储一个地址或者指针的整数类型，X86和X64的指针大小不同，X86使用int类型即可。 当<code>T</code>为使用<code>&amp;</code>或<code>&amp;&amp;</code>定义的引用类型时，<code>exp</code>r必须是一个有址表达式。 有址引用和无址引用之间可以相互转换。</p><p><code>typeid</code>可以检查对象的类型，使用方法为<code>typeid(a)==typeid(A)?</code>或者<code>typeid(*p)!=typeid(D)</code>等，一般都是用作判断。</p><h3 id="自动类型推导">自动类型推导</h3><p>保留字<code>auto</code>在C++中用于类型推导。<code>auto</code>让编译器通过初始值来推算类型，因此<code>auto</code>定义的变量必须有初始值；使用<code>auto</code>推导时，被推导实体不能出现类型说明，但是可以出现存储可变特性<code>const</code>、<code>voilatile</code>和存储位置特性如<code>static</code>、<code>register</code>，<code>inline</code>。使用<code>auto</code>可以在一条语句中声明多个变量，<strong>但必须保证这一条声明语句只能有一个基本数据类型</strong>。</p><p>关键字<code>decltype</code>用来提取表达式的类型。 使用方法如<code>decltype(f()) sum = x;</code>用函数<code>f</code>的返回类型来声明变量<code>sum</code>，并初始化为<code>x</code> 发生在编译时，且不会调用函数<code>f</code>。凡是需要类型的地方均可出现<code>decltype</code>。 可用于变量、成员、参数、返回类型的定义以及<code>new</code>、<code>sizeof</code>、异常列表、强制类型转换。 可用于构成新的类型表达式。</p><h3 id="lamda表达式">Lamda表达式</h3><p>Lambda表达式是C++引入的一种匿名函数。存储Lambda表达式的变量被编译为临时类的对象。 该临时类变量的对象被构造时，此时Lambda表达式被计算。 若未定义存储该临时类对象的变量，则称该Lambda表达式没被计算。</p><p>Lambda表达式的声明格式为<code>[捕获列表](形参列表)mutable 异常说明-&gt;返回类型{函数体}</code>，如<code>auto f = [ ](int x=1)-&gt;int { return x; };</code>捕获列表的参数用于捕获Lambda表达式的外部变量。</p><p>关于捕获列表的参数</p><ul><li>Lambda表达式的外部变量不能是全局变量或static定义的变量也不能是类的成员。 可以是函数参数或函数定义的局部自动变量。</li><li>出现<code>&amp;变量名</code>表示引用捕获外部变量，<code>[&amp;]</code>表示引用捕获所有函数参数或函数定义的局部自动变量。其可写特性同被捕获的外部变量一致。</li><li>出现<code>=变量名</code>表示值捕获外部变量的值（值参传递), <code>[=]</code>表示捕获所有函数参数或函数定义的局部自动变量的值。</li><li>参数表后有<code>mutable</code>表示在Lambda表达式中可以修改“值参传递的可写变量的值”，<strong>但调用后不影响Lambda表达式捕获的对应该可写外部变量的值</strong>。</li></ul><h2 id="第十三章-模板与内存回收">第十三章 模板与内存回收</h2><h3 id="变量模板及其实例">变量模板及其实例</h3><p>C++提供了3种类型的模板，即变量模板、函数模板和类模板。 变量模板使用类型形参<strong>定义变量的类型</strong>，可根据类型实参生成变量模板的实例变量。 生成实例变量的途径有三种：一种是从变量模板隐式地或显式地生成模板实例变量；另一种是通过函数模板和类模板生成。 在定义变量模板时，类型形参的名称可以使用关键字<code>class</code>或者<code>typename</code>定义，即可以使用<code>template&lt;class T&gt;</code>或者<code>template&lt;typename T&gt;</code>。 生成模板实例变量时，将使用实际类型名、类名或类模板实例代替T。如</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi=<span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>)</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> &amp;d=pi&lt;<span class="type">float</span>&gt;;<span class="comment">//将T实例化为float,当然也可以实例化为double等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>变量模板不能再函数内部声明，变量模板生成的模板实例也必须为全局或模块静态变量。模板的参数列表除了可以使用类型形参外，还可以使用非类型的形参，如</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> x=<span class="number">3</span>&gt; 		<span class="comment">//定义变量模板girth，其类型形参为T</span></span><br><span class="line"><span class="type">static</span>  T  girth = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>*<span class="number">2</span>*x);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> &amp;g=girth&lt;<span class="type">double</span>,<span class="number">4</span>&gt;;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>其中非类型的形参可以给出默认值。</p><h3 id="函数模板">函数模板</h3><p>函数模板是使用类型形参定义的函数框架，可根据类型实参生成函数模板的模板实例函数。 函数模板不能在非成员函数的内部声明。 根据函数模板生成的模板实例函数也和函数模板的作用域相同。 在函数模板时，可以使用类型形参和非类型形参。 实例化时非类型形参需要传递常量作为实参。 可以单独定义类的函数成员为函数模板。</p><p>在调用函数时可隐式自动生成模板实例函数（根据实参推断）。 也可使用<code>template 返回类型 函数名&lt;类型实参&gt;(形参列表)</code>，显式强制函数模板按类型实参显式生成模板实例函数。 有时候生成的模板实例函数不能满足要求，可定义特化的模板实例函数隐藏自动生成的模板实例函数(直接理解为重载算了)。 在特化定义模板的实例函数时，一定要给出特化函数的完整定义。</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;	<span class="comment">//class可用typename代替</span></span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">template</span> <span class="type">int</span> <span class="built_in">sum</span>&lt;<span class="type">int</span>&gt;(<span class="type">const</span> <span class="type">int</span> &amp; x, <span class="type">const</span> <span class="type">int</span> &amp;y); <span class="comment">//显式实例化模板函数</span></span><br><span class="line">	<span class="type">double</span> b = <span class="built_in">sum</span>(<span class="number">3.14</span>,<span class="number">2.56</span>);<span class="comment">//隐式实例化模板函数</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="类模板">类模板</h3><p>类模板也称为类属类或参数化的类，用于为相似的类定义一种通用模式。 编译程序根据类型实参生成相应的类模板实例类，也可称为模板类或类模板实例。 类模板既可包含类型参数，也可包括非类型参数。 类型参数可以包含1个以上乃至任意个类型形参。 非类型形参在实例化是必须使用常量做为实参。使用方法如下：</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> v=<span class="number">20</span>&gt;	<span class="comment">//类模板的模板参数列表有非类型形参v，默认值为20</span></span><br><span class="line"><span class="keyword">class</span> VECTOR</span><br><span class="line">{</span><br><span class="line">    T  *data;</span><br><span class="line">    <span class="type">int</span>  size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VECTOR</span>(<span class="type">int</span> n = v+<span class="number">5</span>);		<span class="comment">//由v构成表达式v+5，将其作为构造函数成员形参的默认值</span></span><br><span class="line">    ~<span class="built_in">VECTOR</span>( ) <span class="keyword">noexcept</span>;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>[ ](<span class="type">int</span>);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> v&gt;	 <span class="comment">//在类体外函数实现时，加template&lt;class T, int v&gt;, v不能给缺省值	</span></span><br><span class="line">VECTOR &lt;T, v&gt;::<span class="built_in">VECTOR</span>(<span class="type">int</span> n)	<span class="comment">//须用VECTOR &lt;T, v&gt;作为类名</span></span><br><span class="line">{</span><br><span class="line">    data = <span class="keyword">new</span> T[size = n];  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> v&gt;  <span class="comment">//函数实现时，加template&lt;class T, int v&gt;, v不能给缺省值</span></span><br><span class="line">VECTOR &lt;T, v&gt;::~<span class="built_in">VECTOR</span>( ) <span class="keyword">noexcept</span> 	<span class="comment">//须用VECTOR &lt;T, v&gt;作为类名</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (data) <span class="keyword">delete</span> data;</span><br><span class="line">    data = <span class="literal">nullptr</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> v&gt;</span><br><span class="line">T &amp;VECTOR &lt;T, v&gt;::<span class="keyword">operator</span>[ ](<span class="type">int</span> i) 		<span class="comment">//须用VECTOR &lt;T, v&gt;作为类名</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> data[i];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">VECTOR&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>如果函数是在类体里实现的，实现时不用加<code>template&lt;T&gt;</code></p><p>可以用类模板定义基类和派生类。 在实例化派生类时，如果基类是用类模板定义的，也会同时实例化基类。这里的实例化指模板类实例化，生成实例类 派生类函数在调用基类的函数时，最好使用<code>基类&lt;类型参数&gt;::</code>限定基类函数成员的名称，以帮助编译程序识别函数成员所属的基类。 对于实例化的模板类，如果其名字太长，可以使用<code>typedef</code>重新命名定义。</p><p>当一个类模板有多个类型形参时，在类中只要使用同样的类型形参顺序，都不会影响他们是同一个类型形参模式。</p><p>类模板同样可以定义特化的类，但是和函数的形式有所不同，假设定义一个VECTOR的特化的字符指针的向量类，格式如下</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; &gt;			<span class="comment">//定义特化的字符指针向量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VECTOR</span> &lt;<span class="type">char</span>*&gt;		</span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span>** data;</span><br><span class="line">    <span class="type">int</span>  size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VECTOR</span>(<span class="type">int</span>);			<span class="comment">//特化后其所属类名为VECTOR &lt;char*&gt;</span></span><br><span class="line">    ~<span class="built_in">VECTOR</span>( ) <span class="keyword">noexcept</span>;		<span class="comment">//特化后其所属类名为VECTOR &lt;char*&gt;，不是虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">char</span>*&amp; <span class="keyword">operator</span>[ ](<span class="type">int</span> i) { <span class="keyword">return</span> data[i]; };	<span class="comment">//特化后为虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="实验材料源码及实验报告">实验材料、源码及实验报告</h1><p><a class="uri" target="_blank" rel="noopener" href="https://github.com/zz12138zz/cpp_experiment_of_HUST">https://github.com/zz12138zz/cpp_experiment_of_HUST <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> C++面向对象编程</li><li><strong>Author:</strong> Yizumi Konata</li><li><strong>Created at :</strong> 2020-12-21 14:36:02</li><li><strong>Updated at :</strong> 2024-06-06 23:04:55</li><li><strong>Link:</strong> https://zz12138zz.github.io/2020/12/21/C++/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/C/">#C++</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">#编程语言学习</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">#课程笔记</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2021/01/26/%E7%89%A9%E8%AF%AD%E7%B3%BB%E5%88%97%E6%97%B6%E9%97%B4%E9%A1%BA%E5%BA%8F/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">物语系列已动画化部分时间顺序</span> <span class="post-nav-item">Prev posts</span></span></a></div><div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="next" rel="next" href="/2020/12/21/Git/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">Git简要教程</span> <span class="post-nav-item">Next posts</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://waline233-blond.vercel.app",lang:"zh-CN",dark:'body[class~="dark-mode"]',requiredMeta:["nick","mail"],emoji:[],recaptchaV3Key:"wasd"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">C++面向对象编程</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-c%E5%BC%95%E8%AE%BA"><span class="nav-text">第一章 C++引论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="nav-text">程序设计语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF"><span class="nav-text">程序编译技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"><span class="nav-text">面向对象的程序设计语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">C++语言的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-text">第二章 类型、常量和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-text">C++的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="nav-text">基础类型变量及其类型解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text">指针类型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text">引用类型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88"><span class="nav-text">数组，结构，联合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%AD%E5%8F%A5%E5%87%BD%E6%95%B0%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text">第三章 语句，函数及程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="nav-text">C++的语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">C++的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-c%E7%9A%84%E7%B1%BB"><span class="nav-text">第四章 C++的类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="nav-text">类的声明和定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%8F%8A%E5%AF%B9%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">成员访问权限及对成员的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%92%8C%E4%BD%8D%E6%AE%B5"><span class="nav-text">内联，匿名类和位段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new%E5%92%8Cdelete"><span class="nav-text">new和delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0this"><span class="nav-text">隐藏参数this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">对象的构造与析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">转换构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">拷贝构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%88%90%E5%91%98%E5%8F%8A%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="nav-text">第五章 成员及成员指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="nav-text">实例成员指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constvolatile%E5%92%8Cmutable"><span class="nav-text">const、volatile和mutable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E6%88%90%E5%91%98"><span class="nav-text">静态函数成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%8C%87%E9%92%88"><span class="nav-text">静态成员指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="nav-text">第六章 继承与构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="nav-text">单继承类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F"><span class="nav-text">继承方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">构造与析构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB"><span class="nav-text">父类与子类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7"><span class="nav-text">第七章 可访问性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-1"><span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="nav-text">名字空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%8B%E5%85%83"><span class="nav-text">成员友元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%8F%8B%E5%85%83%E5%8F%8A%E5%85%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">普通友元及其注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81"><span class="nav-text">第八章 虚函数与多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%B1%BB%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">第九章 多继承类与虚基类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">虚基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-text">派生类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">多继承的构造与析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%96%AD%E8%A8%80"><span class="nav-text">第十章 异常与断言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E9%A1%BA%E5%BA%8F"><span class="nav-text">捕获顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3"><span class="nav-text">函数的异常接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-text">断言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">第十一章 运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="nav-text">运算符概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%82%E6%95%B0"><span class="nav-text">运算符参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">特殊运算符的重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90%E8%BD%AC%E6%8D%A2%E5%92%8C%E6%8E%A8%E5%AF%BC"><span class="nav-text">第十二章 类型解析，转换和推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E4%B8%8E%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">显式与隐式类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cast%E7%B3%BB%E5%88%97%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">cast系列类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-text">自动类型推导</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">Lamda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-text">第十三章 模板与内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%85%B6%E5%AE%9E%E4%BE%8B"><span class="nav-text">变量模板及其实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">类模板</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%9D%90%E6%96%99%E6%BA%90%E7%A0%81%E5%8F%8A%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A"><span class="nav-text">实验材料、源码及实验报告</span></a></li></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Yizumi Konata</a><p class="post-count space-x-0.5"><span>11 posts in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/localSearch.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/layouts/lazyload.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div><div id="aplayer"></div><script src="/js/libs/APlayer.min.js"></script><script src="/js/plugins/aplayer.js"></script></body></html>