<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Yizumi Konata"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://example.com/2020/01/21/c语言与程序设计/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="华中科技大学计算机学院19级C语言课程设计笔记，内容大部分来源于教科书和ppt。作者菜的一批，若有任何纰漏或错误可以发邮件至954988021@qq.com指出有误的地方并喷我一顿，十分感谢（不过估计也没人看）"><meta property="og:type" content="article"><meta property="og:title" content="C语言程序设计"><meta property="og:url" content="http://example.com/2020/01/21/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html"><meta property="og:site_name" content="纯路人的博客"><meta property="og:description" content="华中科技大学计算机学院19级C语言课程设计笔记，内容大部分来源于教科书和ppt。作者菜的一批，若有任何纰漏或错误可以发邮件至954988021@qq.com指出有误的地方并喷我一顿，十分感谢（不过估计也没人看）"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231934219.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231950674.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B61.png"><meta property="og:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/C%E7%A8%8B%E5%BA%8F.png"><meta property="article:published_time" content="2020-01-21T02:56:32.000Z"><meta property="article:modified_time" content="2024-06-06T15:04:54.958Z"><meta property="article:author" content="Yizumi Konata"><meta property="article:tag" content="编程语言学习"><meta property="article:tag" content="课程笔记"><meta property="article:tag" content="C语言"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231934219.png"><link rel="icon" type="image/png" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"><meta name="theme-color" content="#6495ED"><link rel="shortcut icon" href="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"><title>C语言程序设计 - 纯路人的博客</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><style>:root{--preloader-background-color:#fff;--preloader-text-color:#000}@media (prefers-color-scheme:dark){:root{--preloader-background-color:#202124;--preloader-text-color:#fff}}@media (prefers-color-scheme:light){:root{--preloader-background-color:#fff;--preloader-text-color:#000}}@media (max-width:600px){.ml13{font-size:2.6rem!important}}.preloader{display:flex;flex-direction:column;gap:1rem;align-items:center;justify-content:center;position:fixed;padding:12px;top:0;right:0;bottom:0;left:0;width:100vw;height:100vh;background-color:var(--preloader-background-color);z-index:1100;transition:opacity .2s ease-in-out}.ml13{font-size:3.2rem;color:var(--preloader-text-color);letter-spacing:-1px;font-weight:500;font-family:Chillax-Variable,sans-serif;text-align:center}.ml13 .word{display:inline-flex;flex-wrap:wrap;white-space:nowrap}.ml13 .letter{display:inline-block;line-height:1em}</style><div class="preloader"><script src="/js/libs/anime.min.js"></script><h1 class="ml13">纯路人的博客</h1><script>var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }</script></div><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/fonts.css"><link rel="stylesheet" href="/fonts/Satoshi/satoshi.css"><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet"><link href="" rel="stylesheet"><script id="hexo-configurations">window.config={hostname:"example.com",root:"/",language:"en",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,title_alignment:"left",headings_top_spacing:{h1:"5rem",h2:"4rem",h3:"2.8rem",h4:"2.5rem",h5:"2.2rem",h6:"2rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#6495ED",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:"FangSong_GB2312",url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/monika.webp",dark:"/images/monika.webp"},title:"为了幸福地生活，我就必须与世界保持一致",subtitle:{text:["Down the rabbit hole..."],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:80,backing_speed:100,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!0,family:"Noto Sans SC",url:"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!0,type:"fixed",audios:[{name:"テルーの呗",artist:"手嶌葵",url:"https://zz12138music.oss-cn-beijing.aliyuncs.com/1.mp3",cover:"https://zz12138music.oss-cn-beijing.aliyuncs.com/1.png",lrc:null},{name:"勘ぐれい",artist:"ずっと真夜中でいいのに",url:"https://zz12138music.oss-cn-beijing.aliyuncs.com/2.jpg",cover:"https://zz12138music.oss-cn-beijing.aliyuncs.com/2.m4a"}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.6.2",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"},Categories:{icon:"fa-regular fa-folder",path:"/categories/"},Tags:{icon:"fa-regular fa-tags",path:"/tags/"},About:{icon:"fa-regular fa-user",path:"/about/"}},search:{enable:!0,preload:!0},tags:{Tags:{icon:"fa-solid fa-tags",path:"/tags/"}},categories:{Categories:{icon:"fa-solid fa-folder",path:"/categories/"}}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="https://zz12138img.oss-cn-beijing.aliyuncs.com/%E7%85%8E%E9%B8%A1%E8%9B%8B.png"> </a><a class="logo-title" href="/">纯路人的博客</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> ARCHIVES</a></li><li class="navbar-item"><a href="/categories/"><i class="fa-regular fa-folder fa-fw"></i> CATEGORIES</a></li><li class="navbar-item"><a href="/tags/"><i class="fa-regular fa-tags fa-fw"></i> TAGS</a></li><li class="navbar-item"><a href="/about/"><i class="fa-regular fa-user fa-fw"></i> ABOUT</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>ARCHIVES </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/categories/"><span>CATEGORIES </span><i class="fa-regular fa-folder fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/tags/"><span>TAGS </span><i class="fa-regular fa-tags fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/about/"><span>ABOUT </span><i class="fa-regular fa-user fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">13</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">C语言程序设计</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="https://zz12138img.oss-cn-beijing.aliyuncs.com/konata.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Yizumi Konata</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2020-01-21 10:56:32</span> <span class="mobile">2020-01-21 10:56:32</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-06-06 23:04:54</span> <span class="mobile">2024-06-06 23:04:54</span> <span class="hover-info">Updated</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">编程语言学习</a>&nbsp;</li><li>| <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>&nbsp;</li><li>| <a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h2 id="c语言简介">C语言简介</h2><h3 id="c语言发展历史">C语言发展历史</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231934219.png" alt="image-20240605231934219"></p><p>其中从BCPL语言B语言为<strong>无类型语言</strong>。C语言源于B语言，与1969至1973年间在UNIX上以B语言为基础设计实现。</p><p>最初的C语言依附于UNIX操作系统，在1978年后被移植到各种类型的计算机上，从此独立于所有操作系统。</p><h3 id="c语言特征">C语言特征</h3><ul><li><strong>语言简洁紧凑</strong>：只有37个关键字，12种语句</li><li><strong>目标代码质量高</strong>：目标代码质量指其所占空间大小和执行速度快慢，C语言编译产生的目标代码的质量可以与汇编媲美</li><li><strong>语言表达能力强</strong>：类型丰富，操作符丰富，对硬件操纵能力强</li><li><strong>语句集简单</strong>：基本语句仅有七种</li><li><strong>流程控制结构化</strong>：支持三种基本结构，引入<code>break</code>和<code>continue</code>，保留<code>goto</code>语句</li><li><strong>弱类型</strong>：支持隐式类型转换</li><li><strong>中级语言</strong>：具备高级语言的表达能力和对计算机硬件良好的控制能力</li><li><strong>书写自由</strong>：书写代码没有强制的格式要求</li><li><strong>可移植性好</strong>：C语言源程序可以不改动或稍加改动便可以移植，重新编译链接后即可运行</li></ul><h3 id="简单的c语言程序实例">简单的C语言程序实例</h3><p></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">char</span> str[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input your name please!\n"</span>);</span><br><span class="line">    gets(name);</span><br><span class="line">    show(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(<span class="type">char</span> str[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello %s"</span>,str);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p></p><p>代码第一行表示导入<code>stdio.h</code>库到程序中，导入后可以在程序中使用<code>stdio.h</code>中的函数，比如之后的<code>printf</code>以及<code>gets</code></p><p>代码第二行是对show函数原型的声明，C语言规定所有函数必须先声明后使用，之后的gets和printf函数原型的声明在<code>stdio.h</code>中。<code>void</code>表示函数无返回值，一个函数执行完后会有返回值，返回值的类型在函数定义时给出，void表示无类型。函数返回值除<code>void</code>外，还可以是<code>int</code>，<code>float</code>，<code>char</code>以及指针和其他更为复杂的类型。show是函数名称，自定义函数的函数名必须是合法的标识符。圆括号里的式子是函数的参数。一个函数可以有多个参数，对于这个函数来说只有一个参数<code>char str[]</code>,一个字符数组的首地址。</p><p>代码第三行为主函数的定义，命名为<code>main</code>的函数称为主函数，一般主函数的返回值设为int类型，参数设为<code>void</code>（注意主函数是可以传特定参数的）。一个C语言程序可以有多个函数，但只能有一个主函数，主函数是程序执行的入口。</p><p>主函数内<code>char name[20]</code>是声明一个名称为<code>name</code>的字符数组，<code>char</code>为变量类型[20]表示长度为20个字符的数组，C语言规定在使用一个变量前必须先声明其类型和名称，之后顺次执行三个函数，<code>printf</code>函数打印指定内容至输出设备，puts函数从输入设备读取值至圆括号中的变量，show函数的作用在后面的定义中，<code>return 0</code>表示函数执行结束后向操作系统返回一个0。返回值类型只要和函数定义时一致就行，但对主函数一般习惯返回0.</p><p>代码最后一部分时<code>show</code>函数的定义。由于<code>show</code>函数的定义在<code>main</code>函数使用<code>show</code>之后，所以才需要开头的声明。若将定义移至main函数前边则可以省去声明语句。<code>show</code>函数的作用也是打印特定内容，其中的<code>str</code>是函数参数，类似数学中函数的<code>x</code>，可以被传入函数的具体值代替，本程序在执行是<code>str</code>会被<code>name</code>替代。</p><p>函数的执行结果是先在屏幕上出现</p><p><code>Input your name please!</code></p><p>输入你的名字（比如<code>Mike</code>）后屏幕出现</p><p><code>Hello Mike</code></p><h2 id="计算机系统及内存编址">计算机系统及内存编址</h2><p>计算机系统的思维导图表示</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/计算机系统.png" alt="计算机系统"></p><p>其中需要注意的是内存，内存以字节为单位<mark>连续线性编址</mark>即按照0x0000，0x0001，0x0002......从低地址到高地址连续线性编号。</p><p>计算机中的常用储存单位：一个二进制位为1比特（1b），8b为一个字节（1B），1024B为1K，1024K为1M，1024M为1G，1024G为1T。</p><p>cpu的数据总线的宽度称为cpu的机器字长</p><h2 id="数字与字符的编码表示">数字与字符的编码表示</h2><h3 id="进位计数制">进位计数制</h3><p>计算机中主要涉及到的进位制有二进制，八进制和十六进制，编写程序时无法表示二进制，通过在八进制数字前加0表示八进制，在十六进制数前加0x表示十六进制，不加前缀的数字为十进制</p><p>进位制数之间的转换</p><ul><li>十进制转k进制：除k取余法</li><li>k进制转十进制：按权展开</li><li>二进制转八进制：从低位到高维三位分组，高位不足补零，将每一组转化为相应八进制数</li><li>二进制转十六进制：四位分组，方法与上面类似</li></ul><h3 id="数的机器码表示">数的机器码表示</h3><p>机器数：最高位为符号位，其余位为数值位，符号位为0时表示正值，为1时表示负值</p><p>真值：机器数的数值位称为机器数的真值</p><p>原码：最高位为符号位，其余各位为数值位，符号位为0表示正，为1表示负</p><p>反码：正数的反码等于其原码，负数的反码为其符号位不变，其余各位按位求反（1变0，0变1）</p><p>补码，正数的原码补码反码都相等，负数的补码等于反码加一</p><p><strong>注意</strong>：原码补码反码都是对整数来说的，浮点数（即小数）的表示方法与整数不同</p><h3 id="字符的编码表示">字符的编码表示</h3><p>ASCII码：对于西文字符采用ASCII码，ASCII码采用单字符编码，最高位留作校检位，低七位用于编码，ASCII码字符集中包含128个字符的编码。只有第七位参与的编码称为基本ASCII码（最高位为0），高字节参与编码称为扩展ASCII码</p><p>汉字编码</p><ul><li>拼音码、五笔字型码：用于输入</li><li>国标码：两字节编码</li><li>区位码：将国标码中的字符按位置划分为94个区，每区94个字符的汉字编码方案，是国标码的变形码，换算关系为 国标码（十六进制）=区位码（十六进制）+0x2020</li><li>机内码：计算机储存和处理汉字的编码，将国标码两个字节的最高位置为1形成，换算关系为机内码（十六进制）=国标码（十六进制）+0x8080</li></ul><h2 id="基本语法词汇与程序元素">基本语法词汇与程序元素</h2><h3 id="字符及词法元素">字符及词法元素</h3><h4 id="字符集">字符集</h4><p>C语言字符集是ASCII码的子集，包括二十六个英文字母的大小写，十个十进制数字，特殊字符如<code>! " # % &amp; ' ( ) * + , - . / : ; &lt; &gt; = ? [ ] \ ^ - { } | ~</code>以及空白字符如空格，换行符，水平制表符，垂直制表符，换页符等。</p><p>有些国家本国字符集不包括所有的C语言字符集，于是标准C语言定义了一组三字符序列。比如有的国家的字符集不包括#字符，于是可以用<code>??=</code>代替<code>#</code>。注意对三字符序列的识别与编译器有关，有点编译器可能不识别三字符序列</p><h4 id="词法元素">词法元素</h4><p>C语言编译器会按照<strong>特定规则</strong>将C程序中的<strong>字符序列</strong>分解为<strong>记号</strong>，记号分为五类：标识符，关键字，常量，运算符和标点符号。</p><p>编译器从左往右收集字符，总是尽量建立最长的记号，即使结果不一定构成有效的C语言程序，如<code>x+++++y</code>,编译器会将其拆分为<code>x++ ++ + y</code>，这是错误的。虽然将其拆解为<code>x++ + ++y</code>是正确的，但是编译器不会这样分解。</p><h3 id="标识符关键字及分隔符">标识符、关键字及分隔符</h3><h4 id="标识符">标识符</h4><p>标识符是用来给变量、常量、数据类型以及函数命名的符号。表示符只能由数字、字母以及下划线组成，且首字符必须是字母和下划线。</p><p>除基本命名规则外，还要求用户自定义的标识符不能与C语言关键字以及程序库中的函数和常量重名，此外受编译系统以及机器的限制，可能还对标识符的长度有要求。</p><p>一般情况下标识符尽量有一定含义，方便阅读程序。</p><h4 id="关键字">关键字</h4><p>关键字是被系统赋予特别含义并有专门用途的标识符，不能作为普通标识符给变量和函数等命名，但可以作为宏名（宏名在程序执行的预处理步骤会被替换，而预处理发生在识别关键字之前）<a class="link" target="_blank" rel="noopener" href="https://baike.baidu.com/item/C语言关键字">C语言关键字 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h4 id="分隔符">分隔符</h4><p>分隔符统称为空白字符包括空格符，制表符，换页符，换行符以及注释符，仅起分隔单词的作用</p><h3 id="基本数据类型">基本数据类型</h3><ul><li>字符类型：分为<code>char</code>和<code>unsigned char</code>，都占一个字节，前者最高位为符号位，后者最高位和其他位一样是数值位，普通char对象是有符号还是无符号的取决于机器，但打印字符总是正的，大多数系统中两者是同一类型。</li><li>整型类型：即整数类型，一般的int类型占2或4字节，<code>short int</code>占2字节，<code>long int</code>占4字节，无<code>unsigned</code>修饰为有符号数，有<code>unsigned</code>修饰为无符号数，相应表示范围有变化</li><li>浮点类型：即小数类型，只有有单精度浮点型<code>float</code>，双精度浮点型<code>double</code>,长双精度浮点型<code>long double</code>三种（没有<code>unsigned</code>的浮点型）。在计算机中二进制浮点数V表示为V = (-1)<sup>S</sup> ✖ M ✖ 2<sup>E</sup>，M为大于等于一小于二的数，称为尾数，E称为阶码。由于M规定为1.xxxxxx，相当于默认整数位为1，编码表示时尾数区其实只保存小数点后的数字。<code>float</code>占四字节，其中最高位为符号位，最高位后八位为指数区，最后二十三位为尾数区。 <code>double</code>占八位，最高位为符号位，中间十一位为指数区，最后五十二位为尾数区。<code>long double</code>型长度由具体定义实现，大于等于<code>double</code></li></ul><p><strong>注意</strong>：</p><ol type="1"><li>区别字符‘1’，整型‘1’，以及之后的字符串“1”</li><li>在数值较小时，比如范围为0到9或者是在ASCII码的范围之内，可以用字符型变量代替整型变量以节省空间，前者减去‘0’即可当作整型0<sub>9使用</sub>（可读性相对较强），后者直接用ASCII码运算（可读性相对较弱）。</li><li>C语言中，当储存数据过大或过小时存在溢出情况，字符型和整型只有上溢（数据过大溢出），浮点型还可能因为指数区精度不足下溢（数据过小而溢出）。浮点数下溢时不会再将尾数位小数点前的数字当作1而是当作0用以输出一个很小的接近0的数字；上溢时会出现特殊提示来提示程序员数据发生上溢</li><li>由于计算机计算浮点数有误差，浮点数不可直接进行是否相等的比较</li></ol><h3 id="常量与变量">常量与变量</h3><h4 id="文字常量">文字常量</h4><p>c语言的文字常量包括整型，浮点型，字符型和字符串型。这里的文字常量可以理解为数据</p><ul><li>整型常量：可以是十进制，八进制和十六进制整数书写，八进制加前缀0，十六进制加前缀0x，无前缀时表示十进制。整型常量也可以带后缀，后缀<code>u</code>表示<code>ubsigned</code>，<code>l</code>表示<code>long</code>，可以在一个整数后面加上<code>u</code>，<code>l</code>，<code>ul</code>，<code>ull</code>，<code>ll</code>（大小写皆可）等表示整数的类型为相应后缀类型。无后缀时表示int。</li><li>浮点型常量：两种表示方法，可以用带小数点的十进制数来表示（小数点前全为0或小数点后全为0时0可以不写）如23.14 .56 12. 等，也可以用科学计数法表示，如45e-3表示0.45，其中e（大小写皆可）±n表示10的±n次方。浮点型也可以加后缀指定其类型，无后缀为<code>double</code>型，加<code>f</code>为浮点型，加<code>l</code>为<code>long double</code></li><li>字符常量：单引号括住单个字符即为一个字符常量。大部分字符常量可以直接用单引号括住字符，一部分字符需要使用转义序列如换行、水平制表，单双引号和反斜线，需要用‘  '的方式表示。一般的字符也可以用数字转义序列表示，即。ooo表示1-3个八进制数字，hh表示1-2个十六进制数字，x为前缀，此时可以用ASCII码的八进制和十六进制表示字符。</li><li>字符串常量：双引号括住的0至多个字符，字符串中有的特殊字符也必须使用转义字符如双引号和单斜线。字符串本质是字符数组，由组成该字符串的字符以及空字符表示，如hello就是'h','e','l','l','o','0'组成的字符数组，用sizeof得到该字符串的大小为6（五个英文字符加一个空字符）</li></ul><h4 id="符号常量及符号常量定义">符号常量及符号常量定义</h4><p>一个符号常量就是一个代表某一个定值的标识符。定义符号常量的方法有#define定义，const定义，枚举类型定义</p><ul><li><code>#define</code>定义常量的方式为<code>#define</code> 标识符 常量</li><li><code>const</code>定义符号常量的方法为<code>const</code>类型名 标识符=常量</li><li>枚举类型定义符号常量的方法为<code>enum 枚举名 {标识符=常量表达式，标识符=常量表达式，……}</code>，每一个标识符是一个枚举常量，枚举常量的类型为<code>int</code>，常量表达式可以不给出，在未给出常量表达式的情况下第一个枚举常量的值为0，第二个为1，第三个为2，以此类推。若只给出部分枚举常量的值的情况下，未给出值的枚举常量的值为其前一个常量的值加1，比如<code>enum test {a=1,b,c=5,d,e};</code>则b为2，d为6，e为7</li></ul><p><strong>注</strong>：三种方式定义常量的区别在于第一种分配内存空间，第二种和第三种都会占用一定的内存空间</p><h4 id="变量定义">变量定义</h4><p>C语言中的变量使用前必须声明，这样编译器参可以为变量分配适当的储存单元</p><p>变量声明的格式为 类型名 变量名=初值；可以不进行初始化。</p><p>可以在一个语句里声明多个变量，如：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>,c;</span><br></pre></td></tr></table></figure></div><p>但是不建议这样写，不方便注释。初始化时每个变量必须显式初始化，下面的声明式不合法的</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=b=<span class="number">3</span>;       <span class="comment">//错误，a没有显式初始化，应改为int a=3,b=3;</span></span><br></pre></td></tr></table></figure></div><h3 id="运算符与表达式">运算符与表达式</h3><p>C语言的运算包括算术运算，关系运算，逻辑运算，自增自减运算，赋值运算，条件运算 ，逗号运算，sizeof运算，位运算</p><ul><li>算术运算：包括<code>+ - * / %</code>，都为双目运算符，其中对<code>/</code>，如果两个操作数都是整数则结果也会是整数，若有一个是浮点数则运算结果为浮点数。另外对两个异号整数相除或取模运算时结果的符号以及取整的方向C89与C99标准不同，注意。</li><li>关系运算：包括<code>&lt; &lt;= &gt; &gt;= == !=</code>，都为双目运算符，关系表达式的计算结果总是<code>int</code>型，1为真，0为假。注意在写程序时要判断<code>a&lt;b&lt;c</code>时不能写<code>if(a&lt;b&lt;c)</code>，写作<code>a&lt;b&lt;c</code>会先算<code>a&lt;b</code>得到1或0，然后1或0再与c比较。应该是<code>if(a&lt;b&amp;&amp;b&lt;c)</code></li><li>逻辑运算：包括<code>!</code>(非)<code>&amp;&amp;</code>(与) <code>||</code>(或)。<code>！</code>是单目其他两个为双目。逻辑运算中整型0，浮点型0.0，空字符'\0'以及空指针为假，非0为真。<strong>注意或运算在出现非0项后就直接结束，不会执行后面的语句。</strong></li><li>自增自减运算：包括前后缀的<code>++</code>和<code>--</code>。只能作用于变量，前缀立即生效，后缀在程序执行到序列点时生效。序列点为<code>&amp;&amp;</code>、<code>||</code>、<code>?:</code>以及<code>，</code>的第一个操作数之后，还有表达式完整结束遇到<code>;</code>时</li><li>赋值运算：右结合，即从右读。除简单的赋值运算外还有复合赋值运算，即一个双目运算符<code>op</code>加上<code>=</code>构成的<code>op=运算符</code>，<code>op</code>可以是算数运算符和位运算符。符合赋值表达式为 <code>表达式1 op= 表达式2</code>，等价于<code>表达式1=表达式1 op 表达式2</code>。</li><li>条件运算：三目运算符<code>?:</code>，一般形式为 <code>表达式1？表达式2：表达式3</code>，先计算表达式1，若其值为非0则计算表达式1，表达式1的值就是该运算的结果，否则计算表达式2，得到的结果为该运算的结果</li><li>逗号运算：表达式的形式为 <code>表达式1，表达式2，…… 表达式n</code>，运算结果b为表达式n的值，即最后一个表达式的值</li><li><code>sizeof</code>运算：有两种形式，第一种为<code>sizeof(类型名)</code>, 得到某个数据类型所占用的储存字节数，第二种为 <code>sizeof 表达式</code>或<code>sizeof(表达式)</code>，若不带圆括号则需要空格，运算结果为表达式结果的类型所占用的字节数</li><li>位运算符：包括<code>~</code>(按位求反)、<code>&amp;</code>(按位与)、<code>|</code>(按位或)、<code>^</code>(按位异或) 、<code>&lt;&lt;</code>(按位左移)、<code>&gt;&gt;</code>(按位右移)，其中按位异或的意思是全为1或全为0时为0，一个为1一个为0时为1。按位左移时高位丢弃，低位填入0，在不丢失有效位时左移n位的结果是<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.023ex" xmlns="http://www.w3.org/2000/svg" width="5.612ex" height="1.551ex" role="img" focusable="false" viewBox="0 -675.5 2480.7 685.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="msup" transform="translate(1473.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></span>；按位右移时低位被丢弃，若操作数为有符号类型高位一般填入符号位（当然也有机器填入0但是很少)，若为无符号类型则填入0 。</li></ul><h3 id="类型转换">类型转换</h3><h4 id="整数提升">整数提升</h4><p>任何表达式中的<code>char</code>、<code>unsigned char</code>、<code>unsigned short</code>都要先转化为<code>int</code>或<code>unsigned</code>参与运算（所有值都可以转化为<code>int</code>时转化为<code>int</code>，否则转化为<code>unsigned</code>）</p><h4 id="算数转换">算数转换</h4><p>当对双目运算符的操作数求值时先进行整数提升，若此时操作数类型还不相同则进行算数转换，也称隐式类型转换，从值域较窄的值向值域较宽的值转化，示意图如下</p><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/image-20240605231950674.png" alt="image-20240605231950569"></p><h4 id="赋值转化">赋值转化</h4><p>赋值运算中右操作数的值转化为左操作数的类型，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s=<span class="number">5</span>,a;</span><br><span class="line"><span class="type">double</span> d=<span class="number">2.9</span>,b;</span><br><span class="line">a=d;</span><br><span class="line">b=s;</span><br></pre></td></tr></table></figure></div><p>此时<code>d</code>的值被转化为<code>short</code>再赋给<code>a</code>，<code>a</code>的值为2</p><p><code>s</code>的值被转化为<code>double</code>再赋给<code>b</code>，<code>b</code>的值为5.0。</p><h4 id="强制类型转换">强制类型转换</h4><p>又称显示类型转换，形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(类型名) 操作数</span><br></pre></td></tr></table></figure></div><p>例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>) a</span><br><span class="line">(<span class="type">double</span>)(<span class="string">'a'</span><span class="number">-32</span>)</span><br></pre></td></tr></table></figure></div><p>第一个表达式的值的类型为<code>double</code>，但变量<code>a</code>的值以及类型不变。第二个表达式的值为65</p><h3 id="枚举类型">枚举类型</h3><p>枚举类型常量的定义在前面已经给出，枚举变量的声明有以下两种方式</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>{</span>RED,GREEN,BLUE};</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">c1</span>,<span class="title">c2</span></span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>{</span>RED,GREEN,BLUE} c1,c2;</span><br></pre></td></tr></table></figure></div><p>枚举变量的类型也为<code>int</code>，取值范围为其对应枚举类型所列出的值。例如对上面的枚举类型<code>color</code>。我们定义了两个<code>color</code>类型的变量<code>c1</code>,<code>c2</code>，只能取值0，1，2。所以给<code>c1</code>和<code>c2</code>赋值时若不为0，1，2都是非法的。</p><p><strong>枚举类型的意义是便于程序阅读，不要和后面的数组搞混。</strong>*</p><h2 id="基本标准输入输出">基本标准输入输出</h2><p>基本标准输入输出函数的定义在头文件<code>stdio.h</code>中，在使用这些函数时需要导入该头文件。其实基于字符与字符串的基本输入输出函数有很多，本章介绍的是最常用的。</p><h3 id="字符输入输出">字符输入输出</h3><p>字符输出函数为<code>putchar</code>，字符输入函数为<code>getchar</code>，函数原型的声明如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div><p>对函数<code>putchar</code>，其传入的参数为所需要输出的字符的ASCII码（当然也可以直接传入字符会做整数提升），函数将ASCII码转化为<code>unsigned char</code>送到标准输出设备中，若函数执行成功则返回输出字符的ASCII码，否则返回EOF</p><p>对函数<code>getchar</code>，其不需要传入参数，函数执行时会从输入流中读取一个字符并将字符转化为<code>int</code>类型后作为返回值返回。<code>getchar</code>函数的执行流程为：</p><ol type="1"><li>检查输入流中是否有字符，有则读取第一个字符后将其转化为<code>int</code>返回，剩余字符留在输入流中。没有则进入等待状态。</li><li>在等待状态中可以通过键盘输入字符，在输入完毕后按下回车，所有之前输入的东西包括回车产生的换行符会被送入输入流</li><li>按下回车的同时<code>getchar</code>激活，回到第1步。</li></ol><h3 id="字符串输入与输出">字符串输入与输出</h3><p>字符串输出函数为<code>puts</code>，字符串输入函数为<code>gets</code>，函数原型的声明如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div><p>对<code>puts</code>函数其参数为要输出的字符串的内存首地址（C语言中没有字符串类型，如前面所介绍的字符串的本质是字符数组，数组的元素在内存中连续存储，由于一个字符串以空字符结尾，所以知道传入字符串首地址就相当于传入字符串，详细内容见数组一章），函数执行时将字符串输入到标准输出设备并在结尾添加换行符。函数正确执行时返回一个非负整数，错误执行时返回EOF</p><p>对<code>gets</code>函数，传入参数为将要用来存放字符串的数组的首地址，执行过程中gets函数从输入流中读取一行字符（以换行符结尾，理解为按一个回车），将结尾的换行符换为空字符存入传入的数组中。为防止越界访问内存地址，s指向的内存缓冲区应该足够大以包含输入的字符串。<code>gets</code>函数相比于后面的格式化输入函数的好处是可以直接输入有空格的字符串，但是由于用户输入的一行字符串的大小未知，而存放输入字符串的数组的大小是已经定好的，可能出现越界访问内存的情况，而该函数没有相应处理办法，因而具有安全隐患，在C11标准中该函数已被删除。</p><h3 id="格式化输入输出">格式化输入输出</h3><h4 id="格式化输出函数printf">格式化输出函数<code>printf</code></h4><p><code>printf</code>的函数原型为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br></pre></td></tr></table></figure></div><p>该函数为参数数目可变的参数，其中第一个参数<code>format</code>是一个字符串，其中的转换说明的个数和转换字符决定了省略号代表的参数个数，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%8.3f"</span>，<span class="number">15</span>，<span class="number">-8.2</span>)</span><br></pre></td></tr></table></figure></div><p>格式字符串中有两个 转换说明，%d和 %8.3f，所以后面跟两个参数，%d代表int型变量，%f代表double型变量，所以后面跟的两个参数一个是整数一个是浮点数。</p><p>函数的返回值是输出到函数输出到标准输出设备中的字符个数。</p><p>转换说明的语法格式为<strong>%[域宽说明]转换字符</strong>，域宽说明部分用来表示输出的对齐方向、输出的数据域的宽度以及精度，转换字符格式如下</p><p>注意要在格式字符串中直接输出%应该要打两个%，在%后跟的不是转换字符时多数系统也会将其作为普通字符输出，但是保险起见还是打两个%。</p><p>对%g的输出，首先以十进制表示这个数的宽度和指数形式表示这个数所占的宽度谁小（宽度就是将数据打印到屏幕上所显示的长度），谁小输出谁</p><p>主要注意小数点的用法就好</p><h4 id="格式化输入函数scanf">格式化输入函数<code>scanf</code></h4><p>函数原型如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*format,...)</span>;</span><br></pre></td></tr></table></figure></div><p><code>scanf</code>函数的调用形式与<code>printf</code>类似，<code>format</code>中的转换说明的个数决定了后面参数的个数，后面的参数都是地址值，读入的数据按转换说明中的格式转化后储存在后面的地址中，函数正确执行时返回值为被转换的数据的个数，遇到文件尾或出错时会返回EOF</p><p>一般情况下函数的调用方式如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> f;</span><br><span class="line"><span class="type">char</span> s[<span class="number">50</span>]</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%f%s"</span>,&amp;a,&amp;f,s);</span><br></pre></td></tr></table></figure></div><p><code>&amp;</code>为取地址符，用来得到变量<code>a</code>和<code>f</code>的地址，<code>s</code>本身就是地址，在数组一章会提到。</p><p>一般情况下<code>scanf</code>的格式字符串中只有转换说明，若有除转换说明以外的除空格和制表符以外的其他字符，则在输入时必须输入一样的字符才能正确执行，比如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"these are %d,%d"</span>,&amp;a,&amp;b);</span><br></pre></td></tr></table></figure></div><p>此时必须在输入的两个整数之前加上these are ，整数之间加逗号才行。</p><p><code>scanf</code>的转换字符与<code>printf</code>类似多一个n，%n的作用时统计输入了多少个字符并将个数储存到特定的储存单元。</p><p><code>scanf</code>函数的转换说明一次只能读入一个输入域。从输入流当前位置开始知道第一个空白字符出现为止（如从键盘输入<code>great days</code>其实就是两个输入域了），或根据转换说明不能被转化的字符之前（如转换字符为%d，从键盘键入的值为3a，则只有3在输入域内），或直至指定域宽内的所有字符都是一个输入域。</p><p>所以<code>scanf</code>函数无法向一个空间读入带空格的字符，也不会对输入的字符自动进行整数提升，只会按照指定格式输入。</p><p><code>scanf</code>在输入时没有像<code>printf</code>函数一样的域宽说明，但是有其特定的可选项</p><table><colgroup><col style="width:15%"><col style="width:84%"></colgroup><thead><tr class="header"><th>可选项</th><th>意义</th></tr></thead><tbody><tr class="odd"><td>m（正整数）</td><td>用于指定域宽，及读入字符的个数，从自然输入域中取前m个字符。当自然输入域不足m时则将自然输入域全部读入为止</td></tr><tr class="even"><td>h</td><td>输入短整数</td></tr><tr class="odd"><td>l</td><td>输入长整数</td></tr><tr class="even"><td>L</td><td>输入长双精度浮点数</td></tr><tr class="odd"><td>*</td><td>跳过输入域</td></tr></tbody></table><p><code>*</code>的用法如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> n1,n2,n3,n4,n5;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %*d %d %*d %d %*d %d %*d %d"</span>,&amp;n1,&amp;n2,&amp;n3,&amp;n4,&amp;n5);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d"</span>,n1,n2,n3,n4,n5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>执行程序时输入<code>1 2 3 4 5 6 7 8 9</code></p><p>输出<code>1 3 5 7 9</code></p><h2 id="流程控制">流程控制</h2><p>计算机程序是由有限条语句构成的序列，语句依次执行，对语句执行次序的控制称为流程控制。</p><p>任何复杂的算法都可以通过顺序、分支、循环三种结构实现，对只包含这三种结构的程序称为结构化程序。</p><p>C语言是很好的结构化程序设计语言，同时也支持部分转移语句。</p><p>C语言的语句分为以下六类</p><ol type="1"><li>表达式语句</li><li>复合语句</li><li>选择语句</li><li>循环语句</li><li>标号语句</li><li>转移语句</li></ol><h3 id="表达式语句">表达式语句</h3><p>一个表达式末尾加一个分号即为一个表达式语句，这个表达式可以是赋值，可以是定义变量，也可以是调用函数，甚至可以没有东西</p><p><strong>注意</strong>：只有加了分号才可以称为语句，在判断题中要注意</p><h3 id="复合语句">复合语句</h3><p>以一对花括号括起来的一组语句称为复合语句。表达式语句在语法上属于一个语句，复合语句中的每一个句子都要加分号但是在反花括号外面不需要。复合语句主要用于if语句和循环语句中。</p><p>一个复合语句称为一个块，在块内定义的变量可以和外面的变量重名并覆盖外界变量，但是块内定义的变量的作用域也仅限于块内</p><p>复合语句可以嵌套，但函数定义不能嵌套，不能在函数体中定义函数</p><h3 id="选择语句">选择语句</h3><h4 id="if语句">if语句</h4><p>if语句有两种格式</p><ol type="1"><li><code>if(条件) 语句1</code></li><li><code>if(条件) 语句1 else 语句2</code></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/未命名文件.png" alt="if语句"></p><p>表达式中的值不为0时执行if后面的语句</p><p>if语句可以嵌套使用如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b){</span><br><span class="line">    <span class="keyword">if</span>(a&gt;c)</span><br><span class="line">        max=a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        max=c;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">if</span>(b&gt;c)</span><br><span class="line">        max=b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        max=c;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>嵌套的if-else语句中else与if的配套规则为：else与其前面最靠近的还未配对的if配对，即内层有优先配对</p><h4 id="switch语句">switch语句</h4><p>switch语句的语法形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式){</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>: 语句序列<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>: 语句序列<span class="number">2</span>;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">default</span>:语句序列;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p><strong>注</strong>：</p><ol type="1"><li><code>switch</code>后括号里的表达式的值必须为整数（整型，字符型，枚举型）</li><li><code>case</code>常量的类型与表达式一致，各个<code>case</code>常量的值不能相等.</li><li><code>switch</code>语句的执行过程是首先定位到表达式的值刚好等于<code>case</code>值的那一条语句，然后执行<strong>后面所有的语句</strong>。如果要只执行某一条语句应该在<code>case</code>语句序列后面加上<code>break</code>。</li><li>当表达式的值与所有的<code>case</code>常量都不相等时执行<code>default</code>语句，<code>default</code>语句至多一个，也可以没有</li><li><code>case</code>和<code>default</code>后面的语句序列可以没有语句也可以有多条语句，多条语句不用打花括号</li><li><code>case</code>执行相同语句时可以写的简略一些，比如下面的例子</li></ol><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a){</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"nice to meet you"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>);<span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>可以改为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a){</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"nice to meet you"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>);<span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>以及</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(a){</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"nice to meet you"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"hey"</span>);<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"hello"</span>);<span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="循环语句">循环语句</h3><p>所有循环语句的循环体都只能是一个语句，所以在需要多条语句时需要借助复合语句。</p><h4 id="while语句">while语句</h4><p><code>while</code>语句的形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure></div><p>括号里的值非零时执行下面的语句。若下面的语句有多条则必须使用复合语句</p><h4 id="for语句">for语句</h4><p><code>for</code>语句的形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)</span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure></div><ol type="1"><li><p>表达式1只在循环开始时进行一次，可用于变量初始化，可以使用逗号运算符。</p></li><li><p>表达式2是循环条件，每次循环开始时进行判断，若其值不为0执行循环体语句，为0则停止循环。</p></li><li><p>表达式3在每次循环结尾执行，可以用于进行改变循环变量</p></li><li><p>三个表达式可以部分或全部省略，但是两个分号不能少，其中表达式2省略时表示无限循环（当然你可以在循环体内部设置跳出循环的转移语句</p></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/未命名文件1.png" alt="for语句"></p><h4 id="do-while语句">do-while语句</h4><p><code>do-while</code>语句的形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">while</span>(表达式)</span><br></pre></td></tr></table></figure></div><p>其与<code>whlie</code>语句差不多，但是会在一开始先执行一次循环体里的内容，类似下面的结构</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语句</span><br><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure></div><p>但是写起来更简洁</p><h3 id="标号语句">标号语句</h3><p>形式为</p><p></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标号:语句</span><br></pre></td></tr></table></figure></div><p></p><p>其中的语句必须是不含标号的C语言语句。上面的语句也称为标号的定义。标号语句主要用在<code>goto</code>语句中</p><h3 id="转移语句">转移语句</h3><h4 id="goto语句">goto语句</h4><p>goto语句的形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> 标号;</span><br></pre></td></tr></table></figure></div><p>上面的语句引用的标号必须定义过，而且<code>goto</code>语句只能作用在一个函数内，不可以跳出函数，但可以跳转到函数内的任意程序块中。执行<code>goto</code>语句时，程序会跳转到标号所在的语句执行，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">intx:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入算式"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">while</span>((op=getchar())!=<span class="string">'\n'</span>){</span><br><span class="line">inty:</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"lf"</span>,&amp;y);</span><br><span class="line">        <span class="keyword">switch</span>(op){</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:x+=y; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:x-=y; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:x*=y; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                <span class="keyword">if</span>(y) x/=y;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"除数为0，请重新输入除数"</span>)；</span><br><span class="line">                    <span class="keyword">goto</span> inty;</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"运算符非法，请重新输入算式"</span>)；</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>该程序为一个计算器，有两个标号分别为<code>intx</code>和<code>inty</code>，在输入的算式为除法且除数为0时执行<code>goto</code>语句使程序跳转到<code>inty</code>处执行，当运算符不为加减乘除时执行goto语句时程序跳转到intx处执行。</p><p><code>goto</code>语句不是程序必须成分，虽然很方便但是使用过多会降低程序的可读性，应该尽量避免使用。</p><h4 id="breakcontinue和return语句">break，continue和return语句</h4><p><code>break</code>语句的作用为</p><ol type="1"><li>用于<code>switch</code>中，中途退出<code>switch</code>语句</li><li>用于循环语句，直接退出循环</li></ol><p><code>continue</code>语句用于循环语句，用于直接跳到循环体末尾</p><ol type="1"><li>用在<code>while</code>或<code>do-while</code>中会直接检验循环条件</li><li>用在<code>for</code>语句中会执行表达式3后再检验循环条件</li></ol><p><code>return</code>语句的功能时从被调用的函数返回调用处，简单理解为结束函数的执行。有两种形式</p><ol type="1"><li>不带表达式，用于无返回值的函数，只表示结束不返回值。</li><li>带表达式，会将表达式的值带回调用处，只能用于有返回值的函数</li></ol><p>一个函数会可以包含多个<code>return</code>函数，一般作为选择语句的子句出现，最终只会执行一个。</p><h2 id="函数与程序结构">函数与程序结构</h2><h3 id="c语言的一般结构">C语言的一般结构</h3><p>在开发和维护大型程序时最好的办法时使用易于管理的结构化编程的方法，自顶而下，逐步求精</p><p>结构化程序设计方法是以模块化设计为中心，将待开发的软件和系统划分为若干独立的模块进行开发，最后将模块组装到一起。实现结构化程序设计的手段具体到C语言是编写自己的函数，把每一个模块设计成一个函数。</p><p>一个C程序由一个或多个函数组成，其中有且只有一个<code>main</code>函数，程序的执行总是从<code>main</code>函数开始，程序执行到一个后面跟有括号的函数名时就调用函数，将程序执行转移到函数。除main函数外的函数分为两类，一类是库函数，如<code>printf</code>，<code>scanf</code>等，包含在相应头文件中，只需包含对应头文件即可使用；第二类是用户自定义函数，需要先给出定义或先声明函数原型再使用。</p><p>组成一个C源文件的程序的各个函数可以编 辑成多个C源文件，各C源文件收中要用到的一些变量与常量的声明以及预处理指令可以编辑成一个后缀为.h的头文件，在每个C文件中包含头文件，则每一个C文件都可以使用该头文件里声明的一些标识符。<img lazyload="" src="/images/loading.svg" data-src="https://zz12138img.oss-cn-beijing.aliyuncs.com/C程序.png" alt="C程序"></p><h3 id="函数的定义与函数原型">函数的定义与函数原型</h3><p>函数的定义一般形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名(参数列表)</span><br><span class="line">{</span><br><span class="line">    声明部分</span><br><span class="line">    语句部分</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>花括号前的部分称为函数头，花括号里的称为函数体</p><p>函数头中类型名为函数返回值的数据类型，可以是除数组以外的任何类型，当为<code>void</code>时表示函数无返回值。函数的返回值通过<code>return</code>语句获得。一般来说函数的返回值的类型应该与函数头中的定义一致。对基本类型，当返回值与函数头的定义不一致时会自动转化，对指针类型则必须手动强制转换为一致，对结构和联合则必须一致</p><p>函数名称必须为合法的标识符，而且最好有实际意义，便于阅读。</p><p>参数列表的参数也称<strong>形式参数</strong>，给出给出形参的过程也是一个变量定义的过程，但是不能像定义普通变量那样一个类型名后面跟好几个变量，每一个形参<strong>必须</strong>有自己的数据类型和名字</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>    <span class="comment">//正确</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> x,y)</span>        <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></div><p>函数体中的变量属于局部变量，作用域仅限于函数体</p><p>函数在调用前需要声明函数原型，函数原型以分号结束，类似函数头，但是不必给出形参的名字，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GuessNum</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GuessNum</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure></div><p>以上原型声明均合法。注意如果将函数原型放在任何函数之外则所有函数都可以使用，若放在某个函数体内则只有在该函数内可以使用。</p><h3 id="函数的调用与参数传递">函数的调用与参数传递</h3><p>函数调用的一般形式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名称(实参列表);</span><br></pre></td></tr></table></figure></div><p>函数调用过程中传递的参数称为实参，若函数不需要接受参数则括号里不需要内容。程序从main函数开始执行，执行到其中的函数调用语句时系统将实参的值传给形参并将控制转移到该函数，执行函数体内的内容，最后将函数的返回值返回到调用处。</p><p>传入实参时应注意实参是有求值顺序的，有的从做往右，有的从右往左，所以尽量不要类似写下面给出的右副作用的语句</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(a,a++);</span><br></pre></td></tr></table></figure></div><p>注意通过实参传值只是将实参的值传递给形参，不会改变实参的值，形参和实参是两个变量而且形参仅作用于函数体内。要通过函数改变实参的值只能通过传地址</p><h3 id="作用域与可见性">作用域与可见性</h3><p>在函数外部（文件开头或函数之间）定义的变量是全局变量，也称外部变量，其作用域是整个程序，程序块（花括号）内部定义的变量是局部变量，其作用域仅限于程序块内部。外部变量的作用域最广，但是当局部变量与外部变量重名时局部变量可见性更强。</p><p>在C程序的不同源文件之间或同一个源文件的不同函数之间共享变量时可以使用外部变量，所以外部变量也可以进行函数间的传值。若外部变量的定义在引用的后面则需进行声明，声明的格式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern 类型 变量名</span><br></pre></td></tr></table></figure></div><p>引用性声明时不分配储存单元，只有定义时分配。好的编程习惯是将外部变量的定义放在程序开头。</p><p>局部变量没有引用性声明，只有定义性声明。过度依赖外部变量会降低函数的独立性，造成封装不好，所以建议使用形参传值，提高函数的通用性</p><h3 id="存储类型">存储类型</h3><p>C/C++程序占用的内存分为一下几个部分</p><ol type="1"><li>代码程序区：存放二进制代码</li><li>静态数据区：存放程序运行期间的用到的数据，空间在编译时分配，整个程序期间数据一直存在，程序结束后由系统释放</li><li>动态数据区（栈）：存放程序运行期间的数据，，空间在程序运行期间由编译器分配，生命周期短于程序运行期</li><li>堆区：由程序员分配释放，若程序员不释放，程序结束时由系统回收</li></ol><p>下面介绍几种存储类型的关键字</p><h4 id="auto">auto</h4><p>只作用于变量，称为自动变量，是局部变量的默认储存方式，一般情况下省略，储存于动态数据区中</p><h4 id="extern">extern</h4><p>既能作用于变量又能作用于函数。</p><p>函数外部定义的变量是外部变量，存储类型为<code>extern</code>，但定义时不使用关键字，储存于静态数据区，未初始化时默认值为0.由于外部变量的作用域时整个程序，所以可能在一个源文件中用到另一个源文件的外部变量，此时需要用到extern进行引用性声明，方式上面已经提到。注意引用过来的变量的作用域是有限的，比如在该源文件的一个函数内部进行外部变量引用性声明，另一个函数无法使用，但在源文件的函数外引用则所有函数都可用。</p><p>函数一般都是全局的，储存类型为<code>extern</code>，在函数定义和函数原型中<strong>可以</strong>使用关键字<code>extern</code>。同样在一个源文件引用另一个源文件的函数时需要<code>extern</code>声明</p><h4 id="static">static</h4><p><code>static</code>可以用于定义<strong>静态局部变量</strong>，静态局部变量的生命周期与自动变量一样，但是其储存于静态数据区，生命周期是与整个函数的运行周期一致的，退出块时变量的值仍保留</p><p>还可以用于定义<strong>静态外部变量</strong>，静态外部变量与外部变量的区别是静态外部变量只能作用于定义它的文件里</p><p>还可以用于定义<strong>静态函数</strong>，静态函数的作用域仅限于定义它的文件</p><h4 id="register">register</h4><p><code>register</code>只能用于定义局部变量，将局部变量储存在寄存器中以加快运算速度，其他方面于局部变量一致，但是用<code>register</code>定义变量只是一种向编译器提供的建议，在寄存器资源不足时编译器会忽略register</p><h2 id="编译预处理">编译预处理</h2><p>以<code>#</code>开头的指令称为预处理指令，这些指令是在编译之前完成的</p><h3 id="include">#include</h3><p><code>#include</code>是文件包含指令，形式有两种</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"文件名"</span></span></span><br></pre></td></tr></table></figure></div><p>作用是用文件的内容取代这一行。被包含的内容没有限制，C编译系统提供的头文件扩展名为.h，设计者可以自行决定自己要包含的文件的路径和后缀。</p><p>可以将文件名换成具体路径，此时双引号和尖括号没有区别。但如果只有文件名的话尖括号会到系统指定的标准目录下寻找，而双引号是先到当前目录下寻找，找不到再到标准目录下寻找。标准目录与系统相关。一般标准头文件用尖括号，用户自定义文件用双引号</p><h3 id="define">#define</h3><p>C语言中允许用一个标识符来表示一个字符串，该标识符称为“宏”，在编译预处理时宏会被无条件的替换为其代表的字符串参与之后的编译。宏的定义由#define完成</p><h4 id="无参宏定义">无参宏定义</h4><p>标准形式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符 字符串</span><br></pre></td></tr></table></figure></div><p>一般用于定义一些常量。</p><h4 id="带参宏定义">带参宏定义</h4><p>一般形式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define 标识符(标识符,标识符,......) 字符串</span><br></pre></td></tr></table></figure></div><p>其中第一个标识符为宏名，括号中的标识符为形参。宏展开时先用字符串替换宏，在用实参替代相应形参，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> square(x) ((x)*(x))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,square(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>在这个程序中<code>square(a)</code>会被无条件替换为<code>a*a</code>，然后将a的值代入算得为2</p><p>注意由于宏的展开是<strong>在编译之前无条件地直接替换</strong>，所以要注意带参宏的括号，比如对上面的宏的字符串，如果直接写成<code>x*x</code></p><p>在计算<code>square(2+3)</code>时会直接替换为<code>2+3*2+3</code>，显然是错误的。</p><h3 id="undef">#undef</h3><p>用于取消宏定义。比如我们包含了一个头文件，现在要定义一个变量假设叫做<code>number</code>，我们不知道这个<code>number</code>是否在头文件中已经定义过了，为了防止宏名的冲突可以先</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> number</span></span><br></pre></td></tr></table></figure></div><p>再来定义变量</p><h3 id="条件编译">条件编译</h3><p>功能类似于<code>if</code>语句，但注意一切<strong>预处理发生在编译之前</strong>，所以常量表达式必须时整型而<strong>不能含有<code>sizeof</code>，枚举型和强制类型转换运算符</strong>。条件编译有三种形式。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 常量表达式</span></span><br><span class="line">	程序</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 常量表达式</span></span><br><span class="line">    程序</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>程序依次判断#if和#elif中常量表达式的值，非0时执行其后的程序</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 标识符</span></span><br><span class="line">	程序</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 常量表达式</span></span><br><span class="line">    程序</span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>首先判断#ifdef后的标识符是否已经被#define定义过，是则执行后面的程序，#elif与第一种用法相同</p><p></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 标识符</span></span><br><span class="line">	程序</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 常量表达式</span></span><br><span class="line">    程序</span><br><span class="line">.......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p></p><p>先判断<code>#ifndef</code>后的表达式是否已经被定义过，未被定义过则执行后面的程序块</p><p>条件编译只会编译符合条件的程序段，所以生成的目标代码比if语句短</p><p>在条件编译中可以使用<code>defined</code>运算符，<code>defined(标识符)</code>或<code>defined</code>标识符 可以判断标识符是否已经被<code>#define</code>定义过，配合逻辑运算以及<code>#if</code>可以用来判断多个宏是否存在</p><h3 id="assert断言">assert断言</h3><p><code>assert</code>宏包含在头文件<code>assert.h</code>中，形式为<code>assert(condition)</code>，若<code>condition</code>为真（非零）则什么都不会发生，若为假则会输出错误信息并终止程序执行，可以用来判断是否出现非法数据。</p><p>频繁调用<code>assert</code>会影响程序性能，可以通过在<code>#include&lt;assert.h&gt;</code>前插入<code>#define NDEBUG</code>来禁用<code>assert</code></p><h2 id="数组">数组</h2><p>数组是同类型的数据在内存中连续存放的集合，下标小的元素在前，小的在后。数组的下标都是从0开始计数</p><h3 id="一维数组">一维数组</h3><p>一维数组只有一个下标，用于表示一个线性数据队列，声明一维数组的形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储类型 类型修饰 数据类型说明 数组名[常量表达式]={初值表}</span><br></pre></td></tr></table></figure></div><p>存储类型即之前提到的<code>auto</code>，<code>extern</code>，<code>static</code>，reg<code>i</code>ster等，类型修饰为<code>const</code>或<code>volatile</code>（前者表示数组不可修改，后者表示可以被其他程序修改），数组名是一个标识符，属于地址常量，储存着数组首地址，常量表达式表示数组的大小。数组在声明时必须确定其大小。初值表是可选项，用于初始数组元素。当有初值表时[]里的常量表达式可以忽略，数组的大小即为初值表中元素的个数。在给定大小后初值表中的元素个数可以小于数组长度，此时只会对前几个元素进行初始化。</p><p>要访问数组里的元素要利用<code>[]</code>下标操作符，数组名<code>[i]</code>表示该数组下标为i的元素。由于编译器不会对下标越界做检查，所以要注意下标不要越界。</p><p>一位数组元素在内存中连续存放，比如对一个<code>int</code>型数组<code>a={1，2，3}</code>，假设第一个元素首的地址为<code>0x12ff74</code>，由于一个整型变量占四字节，所以第二个元素的首地址为<code>0x12ff78</code>，第三个为<code>0x12ff7c</code>。</p><p>注意不可以将两个数组直接做四则运算或者赋值，比如<code>a={1,2,3}</code>,不可以再来个<code>int b[3]=a</code>，这是错误的（之前提到过a其实是一个地址值）</p><p>一维数组直接做函数参数的写法为 数据类型名 数组名[],例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[])</span>;</span><br></pre></td></tr></table></figure></div><p>传入一维数组作为函数参数其实是传地址</p><h4 id="字符数组">字符数组</h4><p>字符数组也是一维数组，所以可以像一维数组那样声明，但是由于字符串也是字符数组，所以在初始化时可以直接=字符串，比如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[]=<span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure></div><p>注意字符串的长度为字符串的储存长度减一</p><p>一些常用的字符串处理函数</p><ul><li><code>int strlen(char s[]);</code> 求字符串长度</li><li><code>void strcpy(char t[],char s[]);</code>将s的内容复制到t中</li><li><code>int strcmp(char s[],char t[]);</code>比较字符串s与t，相等时返回0，前面的字符串大时返回正值，后面的字符串大时返回负值</li><li><code>char *strcat(char t[],char s[]);</code> 将s字符串s连接到t的后面</li><li><code>int strstr(char cs[],char ct[]);</code>判断字串函数，若后面的是前面的子串返回ct在cs中第一次出现的位置，否则返回-1</li><li><code>int trim (char s[]);</code> 删除字符串首尾的空白字符，返回删除后的字符串长度</li></ul><h3 id="多维数组">多维数组</h3><p>多位数组相当于数组的元素还是数组，如二维数组就相当于数组的元素是一维数组，二维数组可以用来描述矩阵或行列式，n维数组可以表示n维线性空间中的n维向量</p><p>n维数组需要n个下标来表示，形式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明 数组名[常量表达式1][常量表达式2]...[常量表达式n]={初值表}</span><br></pre></td></tr></table></figure></div><p>常量表达式1称为第一维，常量表达式2称为第二维，以此类推</p><p>对多维数组元素的间访形式为</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标1][下标2]......[下标n]</span><br></pre></td></tr></table></figure></div><p>由于内存是线性的，所以多维数组的数据在内存中依然线性储存。如前面所说多维数组就是数组套数组，所以储存的顺序为先是最第一级的第一个一维数组的第一个元素，然后将第一个一位数组的元素存完后存第二个一位数组，第一个二维数组中的一维数组存完后存第二个二维数组，以此类推</p><p>对多维数组初始化可以按照上面的储存顺序直接当作一位数组进行初始赋值，也可以按照数组套数组的逻辑方式赋值，以下两种方式都是正确的</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>][<span class="number">2</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line"><span class="type">int</span> b[<span class="number">2</span>][<span class="number">3</span>][<span class="number">2</span>]={{{<span class="number">1</span>,<span class="number">2</span>},{<span class="number">3</span>,<span class="number">4</span>},{<span class="number">5</span>,<span class="number">6</span>}},{{<span class="number">1</span>,<span class="number">2</span>},{<span class="number">3</span>,<span class="number">4</span>},{<span class="number">5</span>,<span class="number">6</span>}}};</span><br></pre></td></tr></table></figure></div><p>初值全部给出时第一维大小，可以省略不写</p><h4 id="二维字符数组">二维字符数组</h4><p>对二维字符数组其实相当于一个字符串数组，除了在初始化时可以直接采用字符串，在其他地方都一样。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">3</span>][<span class="number">10</span>]={<span class="string">"apple"</span>,<span class="string">"banana"</span>,<span class="string">"cucumber"</span>};</span><br><span class="line"><span class="type">char</span> b[][<span class="number">10</span>]={<span class="string">"Java"</span>,<span class="string">"Python"</span>,<span class="string">"Rust"</span>,<span class="string">"Golang"</span>};</span><br></pre></td></tr></table></figure></div><h2 id="指针">指针</h2><p>变量在计算机中以字节为单位储存，每个字节都有其编码，称为地址。大部分类型变量都占有一至多个字节，变量的首字节的地址称为变量的地址，储存地址的变量称为指针</p><h3 id="指针的声明">指针的声明</h3><p>指针的声明形式为</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 数据类型 *标识符<span class="number">1</span>,*标识符<span class="number">2</span>,.....</span><br></pre></td></tr></table></figure></div><p>指针类型是一种派生类型，声明中数据类型部分是其基类型，决定了指针能够指向何种类型的变量。</p><p>指针需要明确基类型是因为指针的操作要求知道变量所占的字节数。指针的类型可以为<code>void</code>，<code>void</code>类型的指针可以储存任何类型的变量的地址，但由于所占字节数为止所以不可以间访。。如果要间访可以通过强制类型转化将<code>void</code>类型转化为其他类型。</p><p>声明的指针在未赋值时处于无所指的状态，称为悬挂指针，其值为一个随机值。</p><h3 id="指针的使用">指针的使用</h3><p>指针的使用主要涉及取地址运算符<code>&amp;</code>和间访运算符<code>*</code></p><p><code>&amp;</code>为单目运算符，用法为<code>&amp;操作数</code> 操作数必须是一个左值，可以得到操作数的地址。例如有以下声明</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">float</span> f[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></div><p><code>&amp;a</code>,<code>&amp;ch</code>,<code>&amp;d</code>都合法，<code>&amp;f</code>不合法，<code>f</code>是地址但不占内存单元。<strong><code>&amp;</code>的操作数必须占有内存单元</strong>。</p><p><code>*</code>也为单目运算符，用法为<code>*</code>操作数 其中的操作数必须是一个基类型明确的指针，作用为得到该指针所指的地址所储存的值，得到的值为一个左值。</p><p><strong>注意所有单目运算符都为第二优先级，结合性为右结合</strong>，只能通过右结合来判断运算关系先后。</p><p>在向函数中传递参数时，之前提到的通过形参传值其实是将实参的值传递给形参，实参和形参的地址值是不同的，所以无法改变实参的值。若要通过函数改变实参的值必须传入实参的地址例如下面的程序</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">    exchange(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;   </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>这个程序的想法是直接将<code>a</code> <code>b</code>的值传给<code>exchange</code>中的<code>a</code> <code>b</code>,在<code>exchange</code>中<code>a</code> <code>b</code>的确交换了，但是<code>main</code>中的<code>a</code> <code>b</code>并没有被交换，两个函数的<code>a</code> <code>b</code>储存的地址并不同，正确的做法是交换地址中储存的值</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">3</span>;</span><br><span class="line">    exchange(&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d"</span>,a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span>* b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t=*a;</span><br><span class="line">    *a=*b;</span><br><span class="line">    *b=t;   </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><h3 id="指针运算">指针运算</h3><p>指针的算数运算仅限于加、减和自增自减，且以<code>sizeof(基类型)</code>为最小变化单位。如定义一个以<code>T</code>为基类型的指针<code>p</code>，<code>p++</code>代表指针后移一个<code>sizeof(T)</code>，<code>p--</code>代表指针前移一个<code>sizeof(T)</code>。两个不同类型的指针之间不能做算术运算，同类型的指针之间的加法运算没有意义。对同一个数组中的元素的地址可以进行减法运算，地址值较大的指针减去地址值较小的指针可以得到得到两个指针所指元素的下标相减，如下面的代码</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> a[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line">    <span class="type">int</span> *p1=a;</span><br><span class="line">    <span class="type">int</span> *p2=&amp;a[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,p2-p1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>最后的执行结果是4，其他情况下指针相减也没有意义</p><p>指针之间可以进行关系运算,但是只有同一数组中元素的指针进行比较才有意义，指针之间比较的作用和指针所指元素的下标之间相比较的意义一样。</p><h3 id="多级指针">多级指针</h3><p>直接指向整型、浮点型、字符型的指针称为一级指针，指向指针的指针称为多级指针</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p1=&amp;a; <span class="comment">//p1是一个一级指针，其基类型为int型</span></span><br><span class="line"><span class="type">int</span> **p2=&amp;p1; <span class="comment">//p2是一个二级指针，其基类型为一个整型一级指针</span></span><br><span class="line"><span class="type">int</span> ***p3=&amp;p2; <span class="comment">//p3是一个三级指针</span></span><br></pre></td></tr></table></figure></div><p>多级指针与一级指针的区别仅在于基类型不同</p><h3 id="用指针表示数组">用指针表示数组</h3><h4 id="用指针表示一维数组">用指针表示一维数组</h4><p>在指针的运算中说过一个T类型指针加上或减去一个整数相当于指针后移或前移<code>sizeof(T)</code>，其效果相当于有数组中有一个元素<code>a[i]</code>，将i加上或减去一个整数。所以我们可以另指针<code>p</code>指向数组中的一个元素，通过改变指针的指向后间访来访问一维数组中的元素</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1;</span><br><span class="line"><span class="type">int</span> *p2;</span><br><span class="line"><span class="type">int</span> *p3;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">p1 = a;   <span class="comment">/*相当于p=&amp;a[0]*/</span></span><br><span class="line">p2 = p1+<span class="number">2</span>;  <span class="comment">/*此时p2指向a[2],即p2=&amp;a[2]*/</span></span><br><span class="line">p3 = p2<span class="number">-1</span>; <span class="comment">/*此时p3指向a[1]*/</span></span><br><span class="line">b=*p3; <span class="comment">/*此时b等于a[1],即b=2*/</span></span><br></pre></td></tr></table></figure></div><p>通过上面的例子不难发现，若<code>p=a</code>，则<code>a[i]==*(p+i)</code>，在运算中我们可以直接<code>a</code>，<code>p</code>可以混用</p><p>同时指针也可以指向一些常量</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p1=<span class="string">"string"</span>;</span><br><span class="line"><span class="type">char</span> *p2=(<span class="type">int</span>[]){<span class="number">2</span>,<span class="number">3</span>};</span><br></pre></td></tr></table></figure></div><p>此时指针内容不可改动</p><h4 id="用指向数组基本元素的指针表示多维数组">用指向数组基本元素的指针表示多维数组</h4><p>多维数组在内存中依然线性存放，根据这个原理我们可以利用指向数组基本元素的指针来表示多维数组。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>]={{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>},{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}};</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> *p=&amp;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">按照上述声明则a[i][j]=*(p+i*<span class="number">3</span>+j)</span><br><span class="line">对于任意高维数组a[m1][m2]...[mn],假设指针p=&amp;a[<span class="number">0</span>][<span class="number">0</span>]...[<span class="number">0</span>],</span><br><span class="line">则a[n1][n2]...[nn]=*(p+n1*m2+n2*m3+...+nn*mn)</span><br></pre></td></tr></table></figure></div><h4 id="用指向数组的指针表示数组">用指向数组的指针表示数组</h4><p>由于数组也是一种数据类型，我们可以直接用一个以数组为基类型的指针指向数组。</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>][<span class="number">2</span>]=a;</span><br></pre></td></tr></table></figure></div><p>以上是指向一个三位数组的指针，此时<code>p</code>和<code>a</code>等价，<code>p</code>的移动以该三维数组中的二维数组的长度为基本单位。其他维数的指针声明类似。</p><p>这种指向数组的指针本质上是一个指针的指针，如上面这个三维数组，这个<code>p</code>储存的其实是第一个二维数组的首地址的地址</p><h3 id="指针数组">指针数组</h3><p><strong>数组元素为指针的数组</strong>称为指针数组，声明形式如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型说明 *指针名[数组长度]		例如：</span><br><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> *str[]={<span class="string">"Hello"</span>,<span class="string">"World"</span>};</span><br></pre></td></tr></table></figure></div><p>其实二维数组就相当于一个一维指针数组。</p><h3 id="指针函数">指针函数</h3><p>返回值为指针的函数声明形式如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类型说明 *函数名(参数表) 如：</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *t,<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure></div><h3 id="指向函数的指针">指向函数的指针</h3><p>任何一个函数经编译之后都会形成对应的一系列机器指令，这些指令的机器码在内存中连续存放，而首次执行指令的地址被称为该函数的入口地址并用函数名进行标识，指向函数的指针就是指向函数入口地址的指针变量，简称函数指针。换言之，函数指针是以函数的入口地址为其值的指针变量。通过函数指针，可以调用函数。函数指针声明方式如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 (*函数指针名)(形参表) 如：</span><br><span class="line"><span class="type">char</span> (*p)(<span class="type">char</span> *,<span class="type">char</span> *);</span><br><span class="line">p=<span class="built_in">strcpy</span>;</span><br></pre></td></tr></table></figure></div><p>函数指针指向的函数的类型和形参表必须与函数指针完全一致，调用函数指针指向的函数时可以使用<code>p(s,t)</code>，也可以使用<code>(*p)(s,t)</code>。</p><h3 id="带参数的main函数">带参数的main函数</h3><p><code>main</code>函数参数又称为命令行参数，指在操作系统环境下执行一个程序时所提供的参数，它提供了程序运行时，向程序提供参数的一种途径。需要使用命令行参数时，main函数在编写时需要带上参数</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    …………</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div><p>其中<code>argc</code>为参数个数，<code>argv[]</code>为存放参数字符串的数组。命令行参数只能传递字符串数组。</p><p>假设编译完成的程序为<code>test.exe</code>，储存在D盘根目录下，则调用<code>test.exe</code>并向其传递命令行参数的方法为</p><div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">test.exe</span> <span class="title">arg1</span> <span class="title">arg2</span></span></span><br></pre></td></tr></table></figure></div><p>参数之间以空格分开。</p><h2 id="结构与联合">结构与联合</h2><p>结构与联合都属于C语言的<strong>构造类型</strong>。 对结构与联合而言，都需要先定义结构类型和联合类型，然后再根据已经定义的结构类型来定义对应的结构变量，以及用已经定义的联合类型来定义对应的联合变量。</p><h3 id="结构">结构</h3><h4 id="结构类型的声明">结构类型的声明</h4><p>结构类型是一种将不同数据类型的成员组织起来所形成的一种新的构造类型。结构类型又称为结构体、聚合类型。C语言中的结构在其他程序设计语言中往往称为记录。</p><p>结构的声明格式如下：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构类型名{</span></span><br><span class="line">    成员声明表</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><p>声明结构类型是用户创建自定义数据类型的过程，不进行存储分配。其中成员声明表说明了成员的数据结构以及类型，和声明变量的格式一致。例如以学生的学习情况描述为例，科声明如下的结构类型：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu_study</span>{</span> 	<span class="comment">/* stu_study是结构类型名 */</span></span><br><span class="line">	<span class="type">char</span> num[<span class="number">12</span>]; <span class="comment">/* 学号成员，字符数组类型 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">9</span>]; <span class="comment">/* 姓名成员，字符数组类型 */</span></span><br><span class="line">	<span class="type">char</span> sex;<span class="comment">/* 性别成员，字符类型 */</span></span><br><span class="line">	<span class="type">int</span> English;	<span class="comment">/* 英语成员，整型 */</span></span><br><span class="line">	<span class="type">int</span> Math,Physics,C;<span class="comment">/* 数学、物理、C语言，整型 */</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><p>在声明结构时应注意以下几点</p><ul><li>同一结构内的成员不能同名</li><li>结构不允许递归定义，即不能再结构中出现包含自身类型的实例，但是可以出现指向自身类型的指针</li><li>结构可以嵌套定义,即一个结构体中可以包含其他结构变量</li><li>同一结构的成员在内存中连续存放，成员存储分配按照结构声明体中不同声明从上向下，同一声明中从左向右的顺序进行，每个成员所占存储空间的大小由其类型确定。由于需要边界对齐，一般用<code>sizeof</code>运算符确定结构变量所占的存储空间的实际大小</li><li>一般而言，成员所占的存储的大小必须在结构类型声明时确定，但根据ISO/IEO 9899标准，作为一个特例，结构中最后一个成员可以具有不完全的数组类型，即最后一个数据成员可以为动态数组</li></ul><h4 id="结构变量的定义">结构变量的定义</h4><p>声明结构变量有两种方法，一种是结构类型和结构变量同时声明，另一种是先声明结构类型再声明结构变量。我们还可以使用<code>typedef</code>定义结构类型名方便声明变量。初始化时可以用花括号给定初值表序列</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构类型和变量同时声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}p1,p2;<span class="comment">//可以在struct前加上存储类型修饰</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先声明结构类型再声明结构变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">address</span>;</span><span class="comment">//声明了一个point类型变量address</span></span><br><span class="line"><span class="comment">//可以在struct前加上存储类型修饰</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">}POINT;</span><br><span class="line">POINT address;<span class="comment">//声明了一个point类型变量address</span></span><br><span class="line"><span class="comment">//可以在struct前加上存储类型修饰</span></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">}p1={<span class="number">1</span>，<span class="number">2</span>},p2={<span class="number">3</span>，<span class="number">4</span>};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p3</span>=</span>{<span class="number">5</span>,<span class="number">6</span>};</span><br></pre></td></tr></table></figure></div><h4 id="结构类型的引用">结构类型的引用</h4><p>结构变量可以进行的操作有赋值，取地址，间接访问。赋值时即将一个结构变量的所有成员的值赋给另一个同类型结构变量的对应成员，<strong>如果有指针类型成员则等号两边的结构变量的对应指针类型成员会指向同一块内存区域</strong></p><p>对结构变量中的成员的引用有两种方法，一种是通过结构名加<code>.</code>运算符，一种时通过指向某个结构变量的指针加<code>-&gt;运算符</code></p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用结构变量中的成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>{</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">}p1={<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line"><span class="type">int</span> point_x=p1.x;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> *<span class="title">ptr1</span>=</span>&amp;p1;</span><br><span class="line"><span class="type">int</span> point_y=ptr1-&gt;y;</span><br></pre></td></tr></table></figure></div><p>嵌套结构类型变量的成员访问只需注意按层次访问即可</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address</span>{</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">coordinates</span>;</span></span><br><span class="line">}p1={<span class="string">"home"</span>,{<span class="number">20</span>,<span class="number">10</span>}};</span><br><span class="line"><span class="type">int</span> home_x=p1.cooedinates.x;</span><br></pre></td></tr></table></figure></div><p>结构类型变量可以有数组，也可以作为函数的返回值。</p><h3 id="联合">联合</h3><p><strong>联合类型成员共享储存</strong>，联合类型的声明如下：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 联合名称{</span></span><br><span class="line">    联合成员声明</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><p>例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">chl</span> {</span></span><br><span class="line">	<span class="type">char</span>	c; 	<span class="comment">/*字符成员*/</span></span><br><span class="line">	<span class="type">short</span>	h; 	<span class="comment">/*短整型成员*/</span></span><br><span class="line">	<span class="type">long</span>	l; 	<span class="comment">/*长整型成员*/</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div><p>联合变量的声明与结构变量一样，C99以前在初始化时只能对第一个成员初始化，C99开始可以在初值表中用<code>.</code>访问指定成员并对其初始化，例如</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">chl</span> <span class="title">v</span>=</span>{<span class="string">'a'</span>};</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">chl</span> <span class="title">w</span>=</span>{.l=<span class="number">0x12345678</span>}</span><br></pre></td></tr></table></figure></div><p>联合成员的引用与结构成员的引用完全相同</p><h3 id="字段结构">字段结构</h3><p>相邻的<strong>若干个二进制位</strong>称为字段。字段结构是一种特殊的<strong>结构类型</strong>，其成员都是字段类型，成员的取值为无符号整数。 组成字段的二进制位的数目成为该字段的宽度。例如：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">w16_bytes</span> {</span>    <span class="comment">/* byte0为低字节, byte1为高字节 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> byte0: <span class="number">8</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> byte1: <span class="number">8</span>; </span><br><span class="line">} ;</span><br></pre></td></tr></table></figure></div><p>字段结构需要注意以下几个问题：</p><ul><li>字段的宽度n必须大于0且小于等于机器字的宽度，比如在32位系统中，n&gt;0且n&lt;=32。</li><li>字段成员的数据类型为无符号类型，应足够容纳该字段相应宽度的数据。比如，字段宽度为9，则该字段类型不能为<code>unsigned char</code>，可以为<code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>。</li><li>所有字段成员的数据类型应该相同，否则会产生空位</li><li>字段结构的成员不能取地址</li></ul><h2 id="文件的输入与输出">文件的输入与输出</h2><h3 id="文件概述">文件概述</h3><p>文件指<strong>内存以外的介质</strong>上以某种形式组织起来的<strong>数据集合或设备</strong>。文件的输入输出即对文件的读写</p><p>文件分为文本文件和二进制文件，文件的读写方式分为顺序读写和随机读写，方法有调用<code>stdio.h</code>中的库函数调用<code>io.h</code>中的接口函数。</p><p>C语言的标准I/O是基于流的输入输出，程序员只需要按照标准I/O提供的库函数对流进行I/O操作就可以完成数据的输入输出。</p><p>流的特点：有缓冲区，动态性，实时性。流的类型：文本流，二进制流（对应两种类型的文件）</p><p>文件从操作步骤分为三步</p><ol type="1"><li><strong>打开文件</strong>，建立文件指针或文件描述符与文件间的关系。</li><li><strong>对文件进行读写操作</strong></li><li><strong>关闭文件</strong>，取消文件指针或文件描述符与文件间的联系</li></ol><h3 id="file指针和标准流式文件">FILE指针和标准流式文件</h3><p><code>FILE</code>是<code>sidio.h</code>中定义的一种结构类型，VC中的定义如下</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span> {</span></span><br><span class="line">    <span class="type">char</span> *_ptr;   <span class="comment">/*当前读写位置指针，即缓冲区中偏移量*/</span></span><br><span class="line">    <span class="type">int</span>   _cnt; 	<span class="comment">/*缓冲区空满*/</span></span><br><span class="line">    <span class="type">char</span> *_base;   <span class="comment">/*指向缓冲区基地址指针*/</span></span><br><span class="line">    <span class="type">int</span>   _flag; 	<span class="comment">/*文件状态标志*/</span></span><br><span class="line">    <span class="type">int</span>   _file; 	<span class="comment">/*文件描述符*/</span></span><br><span class="line">    <span class="type">int</span>   _charbuf; <span class="comment">/*非缓冲回送字符*/</span> </span><br><span class="line">    <span class="type">int</span>   _bufsiz;    <span class="comment">/*缓冲区大小*/</span></span><br><span class="line">    <span class="type">char</span> *_tmpfname;	<span class="comment">/*临时文件描述符*/</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span>  <span class="title">FILE</span>;</span></span><br></pre></td></tr></table></figure></div><p><code>FILE</code>类型的结构变量在打开文件时由系统自动创建，其成员的值也只对系统进行赋值和更新。在VC6.0的头文件<code>stdio.h</code>中，有这样一个声明<code>extern FILE _iob[];</code>，引用了一个数组<code>_iob</code>，该数组元素的个数称为系统中流的数目，C语言标准规定流的数目，也就是打开文件的数目不得小于8。同时在VC中通过<code>#define FOPEN MAX 20</code>规定了一个程序中打开文件的最大数目为20。</p><p>VC6.0中通过如下声明定义了系统的标准流式文件</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> stdin (&amp;_iob[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stdout (&amp;_iob[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stderr (&amp;_iob[2])</span></span><br></pre></td></tr></table></figure></div><p>三个声明分别为指向数组<code>_iob</code>的下标为0，1，2的元素的指针，<code>stdin</code>代表标准输入设备，通常是键盘，<code>stdout</code>代表标准输出设备，通常是显示器，<code>stderr</code>代表标准出错设备，始终是显示器。（<strong>注意前面说过设备也是文件</strong>）</p><h3 id="流式文件的顺序输入与输出">流式文件的顺序输入与输出</h3><p>流式文件的输入输出库函数缺省情况下是按顺序读写方式工作的。</p><h4 id="打开文件">打开文件</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure></div><p><code>fopen</code>函数打开由形参<code>filename</code>指向的字符串所指定的文件，字符串中包含文件名、扩展名、还可以包含驱动器名和目录路径。如果文件打开成功，<code>fopen</code>函数返回一个文件指针(数组<code>_iob</code>某个元素的地址)，否则返回<code>NULL</code>。形参<code>mode</code>指向字符串，该字符串设置文件的打开方式。</p><p><code>mode</code>有以下几种情况：<code>r</code>表示以只读方式打开文本文件，<code>w</code>表示以只写方式打开文本文件并将原文本文件清零（若文件不存在则创建新的文件），<code>a</code>表示只在文本文件尾部进行写。在这三者的基础上加上<code>b</code>表示对二进制文件操作，如<code>rb</code> <code>wb</code> <code>ab</code>;加上<code>+</code>表示以即可读又可写方式打开，区别在于 <code>r+</code>将文件指针指向文件头，原内容不会被清零，<code>w+</code>将文件指针指向文件头后将原内容清空，<code>a+</code>将文件指针指向文件尾。<code>+</code>与<code>b</code>可同时添加，顺序无所谓。</p><h4 id="关闭文件">关闭文件</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *)</span>;</span><br></pre></td></tr></table></figure></div><p>参数为文件指针，<code>fclose</code>函数关闭文件指针所指文件。 它使缓冲区中尚未存盘的数据全部强制性的存盘，释放打开文件时系统分配的输入输出缓冲区，取消<code>FILE</code> 指针与文件之间的映射关系。 如果文件正常关闭，<code>fclose</code>函数返回0，否则返回<code>EOF</code>。</p><h4 id="文件重定向">文件重定向</h4><p>使原本指向A文件的文件指针指向B文件</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> *mode, FILE *fp)</span>;</span><br></pre></td></tr></table></figure></div><p>该函数会先关闭<code>fp</code>指向的文件然后以指定方式打开文件<code>filename</code>并使<code>fp</code>指向它</p><h4 id="基于字符的文件读写">基于字符的文件读写</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * )</span>; <span class="comment">/*从文件中读一个字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span>, FILE *)</span>; <span class="comment">/*向文件中写一个字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetchar</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/*从标准输入设备中读一个字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputchar</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">/*向标准输出设备中写一个字符*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE * stream)</span>; <span class="comment">/*回送字符到流stream*/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符到文件尾时会返回EOF</span></span><br><span class="line"><span class="comment">//常用的getchar()与putchar函数的定义如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getchar()  getc(stdin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> putchar(c) putc((c), stdout)</span></span><br></pre></td></tr></table></figure></div><h4 id="基于字符串的文件读写">基于字符串的文件读写</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;		<span class="comment">//从标准输入流读取一行字符到s指向的内存空间，不读取换行符，读到文件尾或错误时返回NULL</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">puts</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;	<span class="comment">//向标准输出流输出s指向的字符串</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, FILE *stream)</span>;<span class="comment">//从stream中读取n个字符到s指向的内存空间中，不读取换行符，读到文件尾或错误时返回NULL</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;<span class="comment">//向stream输出s指向的字符串</span></span><br></pre></td></tr></table></figure></div><h4 id="文件的格式读写">文件的格式读写</h4><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//向标准输出流打印格式化字符串,返回成功打印字符的个数</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//从标准输入流格式化读入数据，遇到遇到空格或回车就停止，不读取空格回车，返回参数列表中被成功赋值的参数个数</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//向文件stream写入格式化字符串,返回成功写入字符的个数，失败返回负数</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//从文件stream中格式化读入数据，遇到遇到空格或回车就停止，不读取空格回车，返回参数列表中被成功赋值的参数个数，遇到文件尾返回EOF</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//向buffer指向的内存写入格式化字符串,返回成功写入字符的个数，失败返回负数</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;<span class="comment">//从buffer指向的内存中格式化读入数据，遇到遇到空格或回车就停止，不读取空格回车，返回参数列表中被成功赋值的参数个数。</span></span><br></pre></td></tr></table></figure></div><p>判断文件尾还有一个常用函数</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure></div><p>若文件结束返回非0值，若文件未结束返回0</p><h3 id="流式文件的随机输入输出">流式文件的随机输入输出</h3><p>定位文件读写位置使用</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure></div><p>定位值的计算是从基准点<code>whence</code>开始，加上以字节为单位的偏移量<code>offset</code>所得，即文件读写位置=基准点+偏移量。基准点有三种取值，在<code>stdio.h</code>中有定义</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_SET   0  <span class="comment">//表示以文件起始位置为基准点 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_CUR  1  <span class="comment">//表示以文件当前位置为基准点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEEK_END  2  <span class="comment">//表示以文件尾部位置为基准点</span></span></span><br></pre></td></tr></table></figure></div><p>文件定位相关函数还有：</p><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span>  <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;<span class="comment">//获取文件读写位置</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">fgetpos</span><span class="params">(FILE *stream, <span class="type">fpos_t</span> *pos)</span>;<span class="comment">//将stream的位置保存到pos中，其中pos指向fpos_t类型的变量</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">fsetpos</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">fpos_t</span> *pos)</span>;<span class="comment">//将pos指向的位置赋给stream</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;<span class="comment">//将读写位置重置为起始位置</span></span><br></pre></td></tr></table></figure></div></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> C语言程序设计</li><li><strong>Author:</strong> Yizumi Konata</li><li><strong>Created at :</strong> 2020-01-21 10:56:32</li><li><strong>Updated at :</strong> 2024-06-06 23:04:54</li><li><strong>Link:</strong> https://zz12138zz.github.io/2020/01/21/C语言与程序设计/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">#编程语言学习</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">#课程笔记</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/C%E8%AF%AD%E8%A8%80/">#C语言</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2020/12/21/Git/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">Git简要教程</span> <span class="post-nav-item">Prev posts</span></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.mjs";function loadWaline(){init({el:"#waline",serverURL:"https://waline233-8b3m7qpk6-yizumis-projects-08101e13.vercel.app/",lang:"zh-CN",dark:'body[class~="dark-mode"]',requiredMeta:["nick","mail"],emoji:[],recaptchaV3Key:"wasd"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">C语言程序设计</div><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B"><span class="nav-text">C语言简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-text">C语言发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%89%B9%E5%BE%81"><span class="nav-text">C语言特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="nav-text">简单的C语言程序实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%86%85%E5%AD%98%E7%BC%96%E5%9D%80"><span class="nav-text">计算机系统及内存编址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-text">数字与字符的编码表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6"><span class="nav-text">进位计数制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-text">数的机器码表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%9A%84%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="nav-text">字符的编码表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E8%AF%8D%E6%B1%87%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%85%83%E7%B4%A0"><span class="nav-text">基本语法词汇与程序元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%8F%8A%E8%AF%8D%E6%B3%95%E5%85%83%E7%B4%A0"><span class="nav-text">字符及词法元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-text">标识符、关键字及分隔符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%98%E9%87%8F"><span class="nav-text">常量与变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">运算符与表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">基本标准输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">字符输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text">字符串输入与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">格式化输入输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5"><span class="nav-text">表达式语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5"><span class="nav-text">复合语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="nav-text">选择语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%8F%B7%E8%AF%AD%E5%8F%A5"><span class="nav-text">标号语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E8%AF%AD%E5%8F%A5"><span class="nav-text">转移语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">函数与程序结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%93%E6%9E%84"><span class="nav-text">C语言的一般结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-text">函数的定义与函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%8E%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">函数的调用与参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">作用域与可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">存储类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">编译预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#include"><span class="nav-text">#include</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#define"><span class="nav-text">#define</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undef"><span class="nav-text">#undef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-text">条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert%E6%96%AD%E8%A8%80"><span class="nav-text">assert断言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">指针的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">指针的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-text">指针运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88"><span class="nav-text">多级指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E6%95%B0%E7%BB%84"><span class="nav-text">用指针表示数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="nav-text">指针数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-text">指针函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向函数的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84main%E5%87%BD%E6%95%B0"><span class="nav-text">带参数的main函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%B8%8E%E8%81%94%E5%90%88"><span class="nav-text">结构与联合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88"><span class="nav-text">联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="nav-text">字段结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text">文件的输入与输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">文件概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file%E6%8C%87%E9%92%88%E5%92%8C%E6%A0%87%E5%87%86%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6"><span class="nav-text">FILE指针和标准流式文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text">流式文件的顺序输入与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">流式文件的随机输入输出</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Yizumi Konata</a><p class="post-count space-x-0.5"><span>10 posts in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.2</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/localSearch.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/layouts/lazyload.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div><div id="aplayer"></div><script src="/js/libs/APlayer.min.js"></script><script src="/js/plugins/aplayer.js"></script></body></html>